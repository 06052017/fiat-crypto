fancy_rewrite_head = 
match idc in (ident t) return (Compile.value' true t) with
| @ident.Literal t v =>
    match
      t as t0
      return
        (base.base_interp t0 ->
         UnderLets.UnderLets base.type ident var
           (defaults.expr (type.base t0)))
    with
    | base.type.unit =>
        fun v0 : unit => llet default := UnderLets.Base ##(v0)%expr in
        default
    | base.type.Z =>
        fun v0 : Z => llet default := UnderLets.Base ##(v0)%expr in
        default
    | base.type.bool =>
        fun v0 : bool => llet default := UnderLets.Base ##(v0)%expr in
        default
    | base.type.nat =>
        fun v0 : nat => llet default := UnderLets.Base ##(v0)%expr in
        default
    end v
| ident.Nat_succ =>
    fun x : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_succ)%expr @ x)%expr_pat in
    default
| ident.Nat_pred =>
    fun x : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_pred)%expr @ x)%expr_pat in
    default
| ident.Nat_max =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat in
    default
| ident.Nat_mul =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat in
    default
| ident.Nat_add =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat in
    default
| ident.Nat_sub =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat in
    default
| @ident.nil t => llet default := UnderLets.Base []%expr_pat in
    default
| @ident.cons t =>
    fun (x : defaults.expr (type.base t))
      (x0 : defaults.expr (type.base (base.type.list t))) =>
    llet default := UnderLets.Base (x :: x0)%expr_pat in
    default
| @ident.pair A B =>
    fun (x : defaults.expr (type.base A)) (x0 : defaults.expr (type.base B))
    => llet default := UnderLets.Base (x, x0)%expr_pat in
    default
| @ident.fst A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    llet default := UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat in
    default
| @ident.snd A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    llet default := UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat in
    default
| @ident.prod_rect A B T =>
    fun
      (x : defaults.expr (type.base A) ->
           defaults.expr (type.base B) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base T)))
      (x0 : defaults.expr (type.base (A * B)%etype)) =>
    llet default := UnderLets.Base
                      (#(ident.prod_rect)%expr @
                       (λ (x1 : var (type.base A))(x2 : var (type.base B)),
                        UnderLets.to_expr (x ($x1) ($x2)))%expr @ x0)%expr_pat in
    default
| @ident.bool_rect T =>
    fun
      (x
       x0 : defaults.expr (type.base base.type.unit) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base base.type.bool)) =>
    llet default := UnderLets.Base
                      (#(ident.bool_rect)%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x2)))%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat in
    default
| @ident.nat_rect P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    llet default := UnderLets.Base
                      (#(ident.nat_rect)%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x2)))%expr @
                       (λ (x2 : var (type.base base.type.nat))(x3 : var
                                                                    (type.base
                                                                    P)),
                        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat in
    default
| @ident.nat_rect_arrow P Q =>
    fun
      (x : defaults.expr (type.base P) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base Q)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            (defaults.expr (type.base P) ->
             UnderLets.UnderLets base.type ident var
               (defaults.expr (type.base Q))) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base Q)))
      (x1 : defaults.expr (type.base base.type.nat))
      (x2 : defaults.expr (type.base P)) =>
    llet default := UnderLets.Base
                      (#(ident.nat_rect_arrow)%expr @
                       (λ x3 : var (type.base P),
                        UnderLets.to_expr (x ($x3)))%expr @
                       (λ (x3 : var (type.base base.type.nat))(x4 : var
                                                                    (type.base
                                                                    P ->
                                                                    type.base
                                                                    Q)%ptype)
                        (x5 : var (type.base P)),
                        UnderLets.to_expr
                          (x0 ($x3)
                             (fun x6 : defaults.expr (type.base P) =>
                              UnderLets.Base ($x4 @ x6)%expr_pat) ($x5)))%expr @
                       x1 @ x2)%expr_pat in
    default
| @ident.list_rect A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.list_rect)%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x2)))%expr @
                       (λ (x2 : var (type.base A))(x3 : var
                                                          (type.base
                                                             (base.type.list
                                                                A)))(x4 : 
                                                                    var
                                                                    (type.base
                                                                    P)),
                        UnderLets.to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat in
    default
| @ident.list_case A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.list_case)%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x2)))%expr @
                       (λ (x2 : var (type.base A))(x3 : var
                                                          (type.base
                                                             (base.type.list
                                                                A))),
                        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat in
    default
| @ident.List_length T =>
    fun x : defaults.expr (type.base (base.type.list T)) =>
    llet default := UnderLets.Base (#(ident.List_length)%expr @ x)%expr_pat in
    default
| ident.List_seq =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat in
    default
| @ident.List_firstn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.List_firstn)%expr @ x @ x0)%expr_pat in
    default
| @ident.List_skipn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.List_skipn)%expr @ x @ x0)%expr_pat in
    default
| @ident.List_repeat A =>
    fun (x : defaults.expr (type.base A))
      (x0 : defaults.expr (type.base base.type.nat)) =>
    llet default := UnderLets.Base
                      (#(ident.List_repeat)%expr @ x @ x0)%expr_pat in
    default
| @ident.List_combine A B =>
    fun (x : defaults.expr (type.base (base.type.list A)))
      (x0 : defaults.expr (type.base (base.type.list B))) =>
    llet default := UnderLets.Base
                      (#(ident.List_combine)%expr @ x @ x0)%expr_pat in
    default
| @ident.List_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base B)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.List_map)%expr @
                       (λ x1 : var (type.base A),
                        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat in
    default
| @ident.List_app A =>
    fun x x0 : defaults.expr (type.base (base.type.list A)) =>
    llet default := UnderLets.Base (x ++ x0)%expr in
    default
| @ident.List_rev A =>
    fun x : defaults.expr (type.base (base.type.list A)) =>
    llet default := UnderLets.Base (#(ident.List_rev)%expr @ x)%expr_pat in
    default
| @ident.List_flat_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base (base.type.list B))))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.List_flat_map)%expr @
                       (λ x1 : var (type.base A),
                        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat in
    default
| @ident.List_partition A =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base base.type.bool)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.List_partition)%expr @
                       (λ x1 : var (type.base A),
                        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat in
    default
| @ident.List_fold_right A B =>
    fun
      (x : defaults.expr (type.base B) ->
           defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base A)))
      (x0 : defaults.expr (type.base A))
      (x1 : defaults.expr (type.base (base.type.list B))) =>
    llet default := UnderLets.Base
                      (#(ident.List_fold_right)%expr @
                       (λ (x2 : var (type.base B))(x3 : var (type.base A)),
                        UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat in
    default
| @ident.List_update_nth T =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base T) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base (base.type.list T))) =>
    llet default := UnderLets.Base
                      (#(ident.List_update_nth)%expr @ x @
                       (λ x2 : var (type.base T),
                        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat in
    default
| @ident.List_nth_default T =>
    fun (x : defaults.expr (type.base T))
      (x0 : defaults.expr (type.base (base.type.list T)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    llet default := UnderLets.Base
                      (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat in
    default
| ident.Z_add =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x + x0)%expr in
    default
| ident.Z_mul =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x * x0)%expr in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x0 with
            | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc0)%expr_pat x2)
              x1 =>
                match
                  match idc0 with
                  | ident.Z_land => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    llet default0 := fun 'tt =>
                                     llet default0 := fun 'tt =>
                                                      match x1 with
                                                      | #(idc1)%expr_pat =>
                                                          match
                                                            match idc1 with
                                                            | @ident.Literal
                                                              t2 v =>
                                                                match
                                                                  t2 as t3
                                                                  return
                                                                    (base.base_interp
                                                                    t3 ->
                                                                    option Z)
                                                                with
                                                                | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                end v
                                                            | _ => None
                                                            end
                                                          with
                                                          | Some args1 =>
                                                              match
                                                                s0 as t2
                                                                return
                                                                  (Compile.value'
                                                                    false t2 ->
                                                                   UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                              with
                                                              | type.base
                                                                t2 =>
                                                                  fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                  base.try_make_transport_cps
                                                                    (fun
                                                                    t3 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x' v))%expr_pat
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                              | (s1 -> d1)%ptype =>
                                                                  fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                  => default
                                                              end
                                                                (Compile.reflect
                                                                   x2)
                                                          | None => default
                                                          end
                                                      | _ => default
                                                      end in
                                     match x2 with
                                     | #(idc1)%expr_pat =>
                                         match
                                           match idc1 with
                                           | @ident.Literal t2 v =>
                                               match
                                                 t2 as t3
                                                 return
                                                   (base.base_interp t3 ->
                                                    option Z)
                                               with
                                               | base.type.unit =>
                                                   fun _ : unit => None
                                               | base.type.Z =>
                                                   fun v0 : Z => Some v0
                                               | base.type.bool =>
                                                   fun _ : bool => None
                                               | base.type.nat =>
                                                   fun _ : nat => None
                                               end v
                                           | _ => None
                                           end
                                         with
                                         | Some args1 =>
                                             match
                                               s as t2
                                               return
                                                 (Compile.value' false t2 ->
                                                  UnderLets.UnderLets
                                                    base.type ident var
                                                    (defaults.expr
                                                       (type.base base.type.Z)))
                                             with
                                             | type.base t2 =>
                                                 fun
                                                   v : defaults.expr
                                                         (type.base t2) =>
                                                 base.try_make_transport_cps
                                                   (fun t3 : base.type =>
                                                    defaults.expr
                                                      (type.base t3)) t2
                                                   base.type.Z
                                                   (UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            base.type.Z)))
                                                   (fun
                                                      a : option
                                                            (defaults.expr
                                                               (type.base t2) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                    =>
                                                    match a with
                                                    | Some x' =>
                                                        if
                                                         args1 =?
                                                         2
                                                         ^ (2 *
                                                            Z.log2_up args1 /
                                                            2) - 1
                                                        then
                                                         match
                                                           invert_low
                                                             (2 *
                                                              Z.log2_up args1)
                                                             args
                                                         with
                                                         | Some x3 =>
                                                             UnderLets.Base
                                                               (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                (##(x3)%expr,
                                                                x' v))%expr_pat
                                                         | None =>
                                                             match
                                                               s as t3
                                                               return
                                                                 (Compile.value'
                                                                    false t3 ->
                                                                  UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                             with
                                                             | type.base
                                                               t3 =>
                                                                 fun
                                                                   v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                                 base.try_make_transport_cps
                                                                   (fun
                                                                    t4 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4)) t3
                                                                   base.type.Z
                                                                   (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                   (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'0 v0))%expr_pat
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                             | (s1 -> d1)%ptype =>
                                                                 fun
                                                                   _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                 => default
                                                             end
                                                               (Compile.reflect
                                                                  x1)
                                                         end
                                                        else
                                                         match
                                                           s as t3
                                                           return
                                                             (Compile.value'
                                                                false t3 ->
                                                              UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                         with
                                                         | type.base t3 =>
                                                             fun
                                                               v0 : defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                             base.try_make_transport_cps
                                                               (fun
                                                                  t4 : base.type
                                                                =>
                                                                defaults.expr
                                                                  (type.base
                                                                    t4)) t3
                                                               base.type.Z
                                                               (UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                               (fun
                                                                  a0 : 
                                                                   option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                =>
                                                                match a0 with
                                                                | Some x'0 =>
                                                                    if
                                                                    args1 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1)
                                                                    args
                                                                    with
                                                                    | Some
                                                                    x3 =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args1))%expr @
                                                                    (##
                                                                    (x3)%expr,
                                                                    x'0 v0))%expr_pat
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    else
                                                                    default
                                                                | None =>
                                                                    default
                                                                end)
                                                         | (s1 -> d1)%ptype =>
                                                             fun
                                                               _ : Compile.value'
                                                                    false s1 ->
                                                                   Compile.value'
                                                                    true d1
                                                             => default
                                                         end
                                                           (Compile.reflect
                                                              x1)
                                                    | None => default
                                                    end)
                                             | (s1 -> d1)%ptype =>
                                                 fun
                                                   _ : Compile.value' false
                                                         s1 ->
                                                       Compile.value' true d1
                                                 => default
                                             end (Compile.reflect x1)
                                         | None => default0 tt
                                         end
                                     | _ => default0 tt
                                     end in
                    match x1 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr (type.base base.type.Z)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr (type.base base.type.Z)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if
                                        args1 =?
                                        2 ^ (2 * Z.log2_up args1 / 2) - 1
                                       then
                                        match
                                          invert_low (2 * Z.log2_up args1)
                                            args
                                        with
                                        | Some x3 =>
                                            UnderLets.Base
                                              (#(ident.fancy_mulll
                                                   (2 * Z.log2_up args1))%expr @
                                               (##(x3)%expr, x' v))%expr_pat
                                        | None => default
                                        end
                                       else default
                                   | None => default
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 => default
                            end (Compile.reflect x2)
                        | None => default0 tt
                        end
                    | _ => default0 tt
                    end
                | None =>
                    match
                      match idc0 with
                      | ident.Z_shiftr => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x1 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           match
                                             invert_low (2 * args1) args
                                           with
                                           | Some x3 =>
                                               UnderLets.Base
                                                 (#(ident.fancy_mullh
                                                      (2 * args1))%expr @
                                                  (##(x3)%expr, x' v))%expr_pat
                                           | None =>
                                               match
                                                 s0 as t3
                                                 return
                                                   (Compile.value' false t3 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            base.type.Z)))
                                               with
                                               | type.base t3 =>
                                                   fun
                                                     v0 : defaults.expr
                                                            (type.base t3) =>
                                                   base.try_make_transport_cps
                                                     (fun t4 : base.type =>
                                                      defaults.expr
                                                        (type.base t4)) t3
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (defaults.expr
                                                           (type.base
                                                              base.type.Z)))
                                                     (fun
                                                        a0 : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t3) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          match
                                                            invert_high
                                                              (2 * args1)
                                                              args
                                                          with
                                                          | Some x3 =>
                                                              UnderLets.Base
                                                                (#(ident.fancy_mulhh
                                                                    (2 *
                                                                    args1))%expr @
                                                                 (##(x3)%expr,
                                                                 x'0 v0))%expr_pat
                                                          | None => default
                                                          end
                                                      | None => default
                                                      end)
                                               | (s1 -> d1)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s1 ->
                                                         Compile.value' true
                                                           d1 => default
                                               end (Compile.reflect x2)
                                           end
                                       | None => default
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 => default
                                end (Compile.reflect x2)
                            | None => default
                            end
                        | _ => default
                        end
                    | None => default
                    end
                end
            | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ |
              @expr.App _ _ _ s _
              (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
              _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ |
              @expr.App _ _ _ s _
              (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ =>
                default
            | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _
              ($_)%expr _ | @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ |
              @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => default
            | _ => default
            end
        | None => default
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x2) x1 =>
        match match idc with
              | ident.Z_land => Some tt
              | _ => None
              end with
        | Some _ =>
            llet default0 := fun 'tt =>
                             llet default0 := fun 'tt =>
                                              llet default0 := fun 'tt =>
                                                               llet default0 := 
                                                               fun 'tt =>
                                                               llet default0 := 
                                                               fun 'tt =>
                                                               llet default0 := 
                                                               fun 'tt =>
                                                               llet default0 := 
                                                               fun 'tt =>
                                                               llet default0 := 
                                                               fun 'tt =>
                                                               llet default0 := 
                                                               fun 'tt =>
                                                               match x1 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    match
                                                                    x0
                                                                    with
                                                                    | (@expr.App
                                                                    _ _ _ s2
                                                                    _ #(idc1)
                                                                    x4 @ x3)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | ident.Z_shiftr =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    _ =>
                                                                    match
                                                                    x3
                                                                    with
                                                                    | #
                                                                    (idc2)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc2
                                                                    with
                                                                    | @ident.Literal
                                                                    t3 v =>
                                                                    match
                                                                    t3 as t4
                                                                    return
                                                                    (base.base_interp
                                                                    t4 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args2 =>
                                                                    match
                                                                    s0 as t3
                                                                    return
                                                                    (Compile.value'
                                                                    false t3 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t3 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t4 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4)) t3
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    match
                                                                    s2 as t4
                                                                    return
                                                                    (Compile.value'
                                                                    false t4 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t4 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t5 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5)) t4
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    args2))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    ($_)%expr
                                                                    _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    (@expr.Abs
                                                                    _ _ _ _ _
                                                                    _) _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _ 
                                                                    (_ @ _)
                                                                    _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    (@expr.LetIn
                                                                    _ _ _ _ _
                                                                    _ _) _ @
                                                                    _)%expr_pat =>
                                                                    default
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                   | None =>
                                                                    default
                                                                   end
                                                               | _ => default
                                                               end in
                                                               match x2 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    match
                                                                    x0
                                                                    with
                                                                    | (@expr.App
                                                                    _ _ _ s2
                                                                    _ #(idc1)
                                                                    x4 @ x3)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | ident.Z_shiftr =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    _ =>
                                                                    match
                                                                    x3
                                                                    with
                                                                    | #
                                                                    (idc2)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc2
                                                                    with
                                                                    | @ident.Literal
                                                                    t3 v =>
                                                                    match
                                                                    t3 as t4
                                                                    return
                                                                    (base.base_interp
                                                                    t4 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args2 =>
                                                                    match
                                                                    s as t3
                                                                    return
                                                                    (Compile.value'
                                                                    false t3 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t3 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t4 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4)) t3
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    match
                                                                    s2 as t4
                                                                    return
                                                                    (Compile.value'
                                                                    false t4 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t4 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t5 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5)) t4
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    args2 / 2) -
                                                                    1
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    args2))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    ($_)%expr
                                                                    _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    (@expr.Abs
                                                                    _ _ _ _ _
                                                                    _) _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _ 
                                                                    (_ @ _)
                                                                    _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    (@expr.LetIn
                                                                    _ _ _ _ _
                                                                    _ _) _ @
                                                                    _)%expr_pat =>
                                                                    default
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                   | None =>
                                                                    default0
                                                                    tt
                                                                   end
                                                               | _ =>
                                                                   default0
                                                                    tt
                                                               end in
                                                               match x1 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    match
                                                                    x0
                                                                    with
                                                                    | (@expr.App
                                                                    _ _ _ s2
                                                                    _ #(idc1)
                                                                    x4 @ x3)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | ident.Z_land =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    _ =>
                                                                    match
                                                                    x3
                                                                    with
                                                                    | #
                                                                    (idc2)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc2
                                                                    with
                                                                    | @ident.Literal
                                                                    t3 v =>
                                                                    match
                                                                    t3 as t4
                                                                    return
                                                                    (base.base_interp
                                                                    t4 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args2 =>
                                                                    match
                                                                    s0 as t3
                                                                    return
                                                                    (Compile.value'
                                                                    false t3 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t3 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t4 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4)) t3
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    match
                                                                    s2 as t4
                                                                    return
                                                                    (Compile.value'
                                                                    false t4 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t4 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t5 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5)) t4
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    ($_)%expr
                                                                    _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    (@expr.Abs
                                                                    _ _ _ _ _
                                                                    _) _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _ 
                                                                    (_ @ _)
                                                                    _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    (@expr.LetIn
                                                                    _ _ _ _ _
                                                                    _ _) _ @
                                                                    _)%expr_pat =>
                                                                    default
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                   | None =>
                                                                    default0
                                                                    tt
                                                                   end
                                                               | _ =>
                                                                   default0
                                                                    tt
                                                               end in
                                                               match x2 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    match
                                                                    x0
                                                                    with
                                                                    | (@expr.App
                                                                    _ _ _ s2
                                                                    _ #(idc1)
                                                                    x4 @ x3)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | ident.Z_land =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    _ =>
                                                                    match
                                                                    x3
                                                                    with
                                                                    | #
                                                                    (idc2)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc2
                                                                    with
                                                                    | @ident.Literal
                                                                    t3 v =>
                                                                    match
                                                                    t3 as t4
                                                                    return
                                                                    (base.base_interp
                                                                    t4 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args2 =>
                                                                    match
                                                                    s as t3
                                                                    return
                                                                    (Compile.value'
                                                                    false t3 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t3 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t4 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4)) t3
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    match
                                                                    s2 as t4
                                                                    return
                                                                    (Compile.value'
                                                                    false t4 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t4 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t5 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5)) t4
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    ($_)%expr
                                                                    _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    (@expr.Abs
                                                                    _ _ _ _ _
                                                                    _) _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _ 
                                                                    (_ @ _)
                                                                    _ @ _)%expr_pat |
                                                                    (@expr.App
                                                                    _ _ _ s2
                                                                    _
                                                                    (@expr.LetIn
                                                                    _ _ _ _ _
                                                                    _ _) _ @
                                                                    _)%expr_pat =>
                                                                    default
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                   | None =>
                                                                    default0
                                                                    tt
                                                                   end
                                                               | _ =>
                                                                   default0
                                                                    tt
                                                               end in
                                                               match x1 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    match
                                                                    x0
                                                                    with
                                                                    | @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (#
                                                                    (idc1) @
                                                                    x4)%expr_pat
                                                                    x3 =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | ident.Z_land =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    _ =>
                                                                    match
                                                                    x4
                                                                    with
                                                                    | #
                                                                    (idc2)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc2
                                                                    with
                                                                    | @ident.Literal
                                                                    t3 v =>
                                                                    match
                                                                    t3 as t4
                                                                    return
                                                                    (base.base_interp
                                                                    t4 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args2 =>
                                                                    match
                                                                    s0 as t3
                                                                    return
                                                                    (Compile.value'
                                                                    false t3 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t3 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t4 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4)) t3
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    match
                                                                    s1 as t4
                                                                    return
                                                                    (Compile.value'
                                                                    false t4 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t4 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t5 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5)) t4
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x3)
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    #(_)%expr_pat
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    ($_)%expr
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (@expr.Abs
                                                                    _ _ _ _ _
                                                                    _) _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (($_)%expr @
                                                                    _)%expr_pat
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (@expr.Abs
                                                                    _ _ _ _ _
                                                                    _ @ _)%expr_pat
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (_ @ _ @
                                                                    _)%expr_pat
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (@expr.LetIn
                                                                    _ _ _ _ _
                                                                    _ _ @ _)%expr_pat
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (@expr.LetIn
                                                                    _ _ _ _ _
                                                                    _ _) _ =>
                                                                    default
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                   | None =>
                                                                    default0
                                                                    tt
                                                                   end
                                                               | _ =>
                                                                   default0
                                                                    tt
                                                               end in
                                                               match x2 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    match
                                                                    x0
                                                                    with
                                                                    | @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (#
                                                                    (idc1) @
                                                                    x4)%expr_pat
                                                                    x3 =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | ident.Z_land =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    _ =>
                                                                    match
                                                                    x4
                                                                    with
                                                                    | #
                                                                    (idc2)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc2
                                                                    with
                                                                    | @ident.Literal
                                                                    t3 v =>
                                                                    match
                                                                    t3 as t4
                                                                    return
                                                                    (base.base_interp
                                                                    t4 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args2 =>
                                                                    match
                                                                    s as t3
                                                                    return
                                                                    (Compile.value'
                                                                    false t3 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t3 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t4 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4)) t3
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    match
                                                                    s1 as t4
                                                                    return
                                                                    (Compile.value'
                                                                    false t4 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t4 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t5 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5)) t4
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    (args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1) &&
                                                                    (args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1)
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x3)
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    #(_)%expr_pat
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    ($_)%expr
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (@expr.Abs
                                                                    _ _ _ _ _
                                                                    _) _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (($_)%expr @
                                                                    _)%expr_pat
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (@expr.Abs
                                                                    _ _ _ _ _
                                                                    _ @ _)%expr_pat
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (_ @ _ @
                                                                    _)%expr_pat
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (@expr.LetIn
                                                                    _ _ _ _ _
                                                                    _ _ @ _)%expr_pat
                                                                    _ |
                                                                    @expr.App
                                                                    _ _ _ s1
                                                                    _
                                                                    (@expr.LetIn
                                                                    _ _ _ _ _
                                                                    _ _) _ =>
                                                                    default
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                   | None =>
                                                                    default0
                                                                    tt
                                                                   end
                                                               | _ =>
                                                                   default0
                                                                    tt
                                                               end in
                                                               match x1 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    match
                                                                    x0
                                                                    with
                                                                    | #
                                                                    (idc1)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | @ident.Literal
                                                                    t2 v =>
                                                                    match
                                                                    t2 as t3
                                                                    return
                                                                    (base.base_interp
                                                                    t3 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args1 =>
                                                                    match
                                                                    s0 as t2
                                                                    return
                                                                    (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t2 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t3 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    if
                                                                    args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                   | None =>
                                                                    default0
                                                                    tt
                                                                   end
                                                               | _ =>
                                                                   default0
                                                                    tt
                                                               end in
                                              match x2 with
                                              | #(idc0)%expr_pat =>
                                                  match
                                                    match idc0 with
                                                    | @ident.Literal t1 v =>
                                                        match
                                                          t1 as t2
                                                          return
                                                            (base.base_interp
                                                               t2 -> 
                                                             option Z)
                                                        with
                                                        | base.type.unit =>
                                                            fun _ : unit =>
                                                            None
                                                        | base.type.Z =>
                                                            fun v0 : Z =>
                                                            Some v0
                                                        | base.type.bool =>
                                                            fun _ : bool =>
                                                            None
                                                        | base.type.nat =>
                                                            fun _ : nat =>
                                                            None
                                                        end v
                                                    | _ => None
                                                    end
                                                  with
                                                  | Some args0 =>
                                                      match x0 with
                                                      | #(idc1)%expr_pat =>
                                                          match
                                                            match idc1 with
                                                            | @ident.Literal
                                                              t2 v =>
                                                                match
                                                                  t2 as t3
                                                                  return
                                                                    (base.base_interp
                                                                    t3 ->
                                                                    option Z)
                                                                with
                                                                | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                end v
                                                            | _ => None
                                                            end
                                                          with
                                                          | Some args1 =>
                                                              match
                                                                s as t2
                                                                return
                                                                  (Compile.value'
                                                                    false t2 ->
                                                                   UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                              with
                                                              | type.base
                                                                t2 =>
                                                                  fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                  base.try_make_transport_cps
                                                                    (fun
                                                                    t3 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    if
                                                                    args0 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0 / 2) -
                                                                    1
                                                                    then
                                                                    match
                                                                    invert_high
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0)
                                                                    args1
                                                                    with
                                                                    | Some
                                                                    y =>
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mullh
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    ##
                                                                    (y)%expr))%expr_pat
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                              | (s1 -> d1)%ptype =>
                                                                  fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                  => default
                                                              end
                                                                (Compile.reflect
                                                                   x1)
                                                          | None => default
                                                          end
                                                      | _ => default
                                                      end
                                                  | None => default0 tt
                                                  end
                                              | _ => default0 tt
                                              end in
                             match x1 with
                             | #(idc0)%expr_pat =>
                                 match
                                   match idc0 with
                                   | @ident.Literal t1 v =>
                                       match
                                         t1 as t2
                                         return
                                           (base.base_interp t2 -> option Z)
                                       with
                                       | base.type.unit =>
                                           fun _ : unit => None
                                       | base.type.Z => fun v0 : Z => Some v0
                                       | base.type.bool =>
                                           fun _ : bool => None
                                       | base.type.nat => fun _ : nat => None
                                       end v
                                   | _ => None
                                   end
                                 with
                                 | Some args0 =>
                                     match x0 with
                                     | #(idc1)%expr_pat =>
                                         match
                                           match idc1 with
                                           | @ident.Literal t2 v =>
                                               match
                                                 t2 as t3
                                                 return
                                                   (base.base_interp t3 ->
                                                    option Z)
                                               with
                                               | base.type.unit =>
                                                   fun _ : unit => None
                                               | base.type.Z =>
                                                   fun v0 : Z => Some v0
                                               | base.type.bool =>
                                                   fun _ : bool => None
                                               | base.type.nat =>
                                                   fun _ : nat => None
                                               end v
                                           | _ => None
                                           end
                                         with
                                         | Some args1 =>
                                             match
                                               s0 as t2
                                               return
                                                 (Compile.value' false t2 ->
                                                  UnderLets.UnderLets
                                                    base.type ident var
                                                    (defaults.expr
                                                       (type.base base.type.Z)))
                                             with
                                             | type.base t2 =>
                                                 fun
                                                   v : defaults.expr
                                                         (type.base t2) =>
                                                 base.try_make_transport_cps
                                                   (fun t3 : base.type =>
                                                    defaults.expr
                                                      (type.base t3)) t2
                                                   base.type.Z
                                                   (UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            base.type.Z)))
                                                   (fun
                                                      a : option
                                                            (defaults.expr
                                                               (type.base t2) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                    =>
                                                    match a with
                                                    | Some x' =>
                                                        if
                                                         args0 =?
                                                         2
                                                         ^ (2 *
                                                            Z.log2_up args0 /
                                                            2) - 1
                                                        then
                                                         match
                                                           invert_low
                                                             (2 *
                                                              Z.log2_up args0)
                                                             args1
                                                         with
                                                         | Some y =>
                                                             UnderLets.Base
                                                               (#(ident.fancy_mulll
                                                                    (2 *
                                                                    Z.log2_up
                                                                    args0))%expr @
                                                                (x' v,
                                                                ##(y)%expr))%expr_pat
                                                         | None => default
                                                         end
                                                        else default
                                                    | None => default
                                                    end)
                                             | (s1 -> d1)%ptype =>
                                                 fun
                                                   _ : Compile.value' false
                                                         s1 ->
                                                       Compile.value' true d1
                                                 => default
                                             end (Compile.reflect x2)
                                         | None => default
                                         end
                                     | _ => default
                                     end
                                 | None => default0 tt
                                 end
                             | _ => default0 tt
                             end in
            match x2 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match x0 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr (type.base base.type.Z)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr (type.base base.type.Z)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if
                                        args0 =?
                                        2 ^ (2 * Z.log2_up args0 / 2) - 1
                                       then
                                        match
                                          invert_low (2 * Z.log2_up args0)
                                            args1
                                        with
                                        | Some y =>
                                            UnderLets.Base
                                              (#(ident.fancy_mulll
                                                   (2 * Z.log2_up args0))%expr @
                                               (x' v, ##(y)%expr))%expr_pat
                                        | None => default
                                        end
                                       else default
                                   | None => default
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 => default
                            end (Compile.reflect x1)
                        | None => default
                        end
                    | _ => default
                    end
                | None => default0 tt
                end
            | _ => default0 tt
            end
        | None =>
            match
              match idc with
              | ident.Z_shiftr => Some tt
              | _ => None
              end
            with
            | Some _ =>
                match x1 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match x0 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr (type.base base.type.Z)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base base.type.Z)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           match
                                             invert_low (2 * args0) args1
                                           with
                                           | Some y =>
                                               UnderLets.Base
                                                 (#(ident.fancy_mulhl
                                                      (2 * args0))%expr @
                                                  (x' v, ##(y)%expr))%expr_pat
                                           | None =>
                                               match
                                                 s0 as t3
                                                 return
                                                   (Compile.value' false t3 ->
                                                    UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            base.type.Z)))
                                               with
                                               | type.base t3 =>
                                                   fun
                                                     v0 : defaults.expr
                                                            (type.base t3) =>
                                                   base.try_make_transport_cps
                                                     (fun t4 : base.type =>
                                                      defaults.expr
                                                        (type.base t4)) t3
                                                     base.type.Z
                                                     (UnderLets.UnderLets
                                                        base.type ident var
                                                        (defaults.expr
                                                           (type.base
                                                              base.type.Z)))
                                                     (fun
                                                        a0 : option
                                                               (defaults.expr
                                                                  (type.base
                                                                    t3) ->
                                                                defaults.expr
                                                                  (type.base
                                                                    base.type.Z))
                                                      =>
                                                      match a0 with
                                                      | Some x'0 =>
                                                          match
                                                            invert_high
                                                              (2 * args0)
                                                              args1
                                                          with
                                                          | Some y =>
                                                              UnderLets.Base
                                                                (#(ident.fancy_mulhh
                                                                    (2 *
                                                                    args0))%expr @
                                                                 (x'0 v0,
                                                                 ##(y)%expr))%expr_pat
                                                          | None => default
                                                          end
                                                      | None => default
                                                      end)
                                               | (s1 -> d1)%ptype =>
                                                   fun
                                                     _ : Compile.value' false
                                                           s1 ->
                                                         Compile.value' true
                                                           d1 => default
                                               end (Compile.reflect x2)
                                           end
                                       | None => default
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 => default
                                end (Compile.reflect x2)
                            | None => default
                            end
                        | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ #(idc1)%expr_pat x4) x3 =>
                            match
                              match idc1 with
                              | ident.Z_land => Some tt
                              | _ => None
                              end
                            with
                            | Some _ =>
                                llet default0 := fun 'tt =>
                                                 match x3 with
                                                 | #(idc2)%expr_pat =>
                                                     match
                                                       match idc2 with
                                                       | @ident.Literal t3
                                                         v =>
                                                           match
                                                             t3 as t4
                                                             return
                                                               (base.base_interp
                                                                  t4 ->
                                                                option Z)
                                                           with
                                                           | base.type.unit =>
                                                               fun _ : unit
                                                               => None
                                                           | base.type.Z =>
                                                               fun v0 : Z =>
                                                               Some v0
                                                           | base.type.bool =>
                                                               fun _ : bool
                                                               => None
                                                           | base.type.nat =>
                                                               fun _ : nat =>
                                                               None
                                                           end v
                                                       | _ => None
                                                       end
                                                     with
                                                     | Some args2 =>
                                                         match
                                                           s0 as t3
                                                           return
                                                             (Compile.value'
                                                                false t3 ->
                                                              UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                         with
                                                         | type.base t3 =>
                                                             fun
                                                               v : defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                             base.try_make_transport_cps
                                                               (fun
                                                                  t4 : base.type
                                                                =>
                                                                defaults.expr
                                                                  (type.base
                                                                    t4)) t3
                                                               base.type.Z
                                                               (UnderLets.UnderLets
                                                                  base.type
                                                                  ident var
                                                                  (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                               (fun
                                                                  a : 
                                                                   option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                =>
                                                                match a with
                                                                | Some x' =>
                                                                    match
                                                                    s2 as t4
                                                                    return
                                                                    (Compile.value'
                                                                    false t4 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t4 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t5 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t5)) t4
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    args2 =?
                                                                    2
                                                                    ^ 
                                                                    (2 *
                                                                    args0 / 2) -
                                                                    1
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhl
                                                                    (2 *
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s3 ->
                                                                    d3)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s3 ->
                                                                    Compile.value'
                                                                    true d3
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                | None =>
                                                                    default
                                                                end)
                                                         | (s3 -> d3)%ptype =>
                                                             fun
                                                               _ : Compile.value'
                                                                    false s3 ->
                                                                   Compile.value'
                                                                    true d3
                                                             => default
                                                         end
                                                           (Compile.reflect
                                                              x2)
                                                     | None => default
                                                     end
                                                 | _ => default
                                                 end in
                                match x4 with
                                | #(idc2)%expr_pat =>
                                    match
                                      match idc2 with
                                      | @ident.Literal t3 v =>
                                          match
                                            t3 as t4
                                            return
                                              (base.base_interp t4 ->
                                               option Z)
                                          with
                                          | base.type.unit =>
                                              fun _ : unit => None
                                          | base.type.Z =>
                                              fun v0 : Z => Some v0
                                          | base.type.bool =>
                                              fun _ : bool => None
                                          | base.type.nat =>
                                              fun _ : nat => None
                                          end v
                                      | _ => None
                                      end
                                    with
                                    | Some args2 =>
                                        match
                                          s0 as t3
                                          return
                                            (Compile.value' false t3 ->
                                             UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                        with
                                        | type.base t3 =>
                                            fun
                                              v : defaults.expr
                                                    (type.base t3) =>
                                            base.try_make_transport_cps
                                              (fun t4 : base.type =>
                                               defaults.expr (type.base t4))
                                              t3 base.type.Z
                                              (UnderLets.UnderLets base.type
                                                 ident var
                                                 (defaults.expr
                                                    (type.base base.type.Z)))
                                              (fun
                                                 a : option
                                                       (defaults.expr
                                                          (type.base t3) ->
                                                        defaults.expr
                                                          (type.base
                                                             base.type.Z)) =>
                                               match a with
                                               | Some x' =>
                                                   match
                                                     s1 as t4
                                                     return
                                                       (Compile.value' false
                                                          t4 ->
                                                        UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                   with
                                                   | type.base t4 =>
                                                       fun
                                                         v0 : defaults.expr
                                                                (type.base t4)
                                                       =>
                                                       base.try_make_transport_cps
                                                         (fun t5 : base.type
                                                          =>
                                                          defaults.expr
                                                            (type.base t5))
                                                         t4 base.type.Z
                                                         (UnderLets.UnderLets
                                                            base.type ident
                                                            var
                                                            (defaults.expr
                                                               (type.base
                                                                  base.type.Z)))
                                                         (fun
                                                            a0 : option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                          =>
                                                          match a0 with
                                                          | Some x'0 =>
                                                              if
                                                               args2 =?
                                                               2
                                                               ^ (2 * args0 /
                                                                  2) - 1
                                                              then
                                                               UnderLets.Base
                                                                 (#(ident.fancy_mulhl
                                                                    (2 *
                                                                    args0))%expr @
                                                                  (x' v,
                                                                  x'0 v0))%expr_pat
                                                              else default
                                                          | None => default
                                                          end)
                                                   | (s3 -> d3)%ptype =>
                                                       fun
                                                         _ : Compile.value'
                                                               false s3 ->
                                                             Compile.value'
                                                               true d3 =>
                                                       default
                                                   end (Compile.reflect x3)
                                               | None => default
                                               end)
                                        | (s3 -> d3)%ptype =>
                                            fun
                                              _ : Compile.value' false s3 ->
                                                  Compile.value' true d3 =>
                                            default
                                        end (Compile.reflect x2)
                                    | None => default0 tt
                                    end
                                | _ => default0 tt
                                end
                            | None =>
                                match
                                  match idc1 with
                                  | ident.Z_shiftr => Some tt
                                  | _ => None
                                  end
                                with
                                | Some _ =>
                                    match x3 with
                                    | #(idc2)%expr_pat =>
                                        match
                                          match idc2 with
                                          | @ident.Literal t3 v =>
                                              match
                                                t3 as t4
                                                return
                                                  (base.base_interp t4 ->
                                                   option Z)
                                              with
                                              | base.type.unit =>
                                                  fun _ : unit => None
                                              | base.type.Z =>
                                                  fun v0 : Z => Some v0
                                              | base.type.bool =>
                                                  fun _ : bool => None
                                              | base.type.nat =>
                                                  fun _ : nat => None
                                              end v
                                          | _ => None
                                          end
                                        with
                                        | Some args2 =>
                                            match
                                              s0 as t3
                                              return
                                                (Compile.value' false t3 ->
                                                 UnderLets.UnderLets
                                                   base.type ident var
                                                   (defaults.expr
                                                      (type.base base.type.Z)))
                                            with
                                            | type.base t3 =>
                                                fun
                                                  v : defaults.expr
                                                        (type.base t3) =>
                                                base.try_make_transport_cps
                                                  (fun t4 : base.type =>
                                                   defaults.expr
                                                     (type.base t4)) t3
                                                  base.type.Z
                                                  (UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                                  (fun
                                                     a : option
                                                           (defaults.expr
                                                              (type.base t3) ->
                                                            defaults.expr
                                                              (type.base
                                                                 base.type.Z))
                                                   =>
                                                   match a with
                                                   | Some x' =>
                                                       match
                                                         s2 as t4
                                                         return
                                                           (Compile.value'
                                                              false t4 ->
                                                            UnderLets.UnderLets
                                                              base.type ident
                                                              var
                                                              (defaults.expr
                                                                 (type.base
                                                                    base.type.Z)))
                                                       with
                                                       | type.base t4 =>
                                                           fun
                                                             v0 : defaults.expr
                                                                    (type.base
                                                                    t4) =>
                                                           base.try_make_transport_cps
                                                             (fun
                                                                t5 : base.type
                                                              =>
                                                              defaults.expr
                                                                (type.base t5))
                                                             t4 base.type.Z
                                                             (UnderLets.UnderLets
                                                                base.type
                                                                ident var
                                                                (defaults.expr
                                                                   (type.base
                                                                    base.type.Z)))
                                                             (fun
                                                                a0 : 
                                                                 option
                                                                   (defaults.expr
                                                                    (type.base
                                                                    t4) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                              =>
                                                              match a0 with
                                                              | Some x'0 =>
                                                                  if
                                                                   args0 =?
                                                                   args2
                                                                  then
                                                                   UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_mulhh
                                                                    (2 *
                                                                    args0))%expr @
                                                                    (
                                                                    x' v,
                                                                    x'0 v0))%expr_pat
                                                                  else
                                                                   default
                                                              | None =>
                                                                  default
                                                              end)
                                                       | (s3 -> d3)%ptype =>
                                                           fun
                                                             _ : Compile.value'
                                                                   false s3 ->
                                                                 Compile.value'
                                                                   true d3 =>
                                                           default
                                                       end
                                                         (Compile.reflect x4)
                                                   | None => default
                                                   end)
                                            | (s3 -> d3)%ptype =>
                                                fun
                                                  _ : Compile.value' false s3 ->
                                                      Compile.value' true d3
                                                => default
                                            end (Compile.reflect x2)
                                        | None => default
                                        end
                                    | _ => default
                                    end
                                | None => default
                                end
                            end
                        | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ ($_)%expr _) _ | @expr.App _
                          _ _ s1 _
                          (@expr.App _ _ _ s2 _ (@expr.Abs _ _ _ _ _ _) _)
                          _ | @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ (_ @ _)%expr_pat _) _ |
                          @expr.App _ _ _ s1 _
                          (@expr.App _ _ _ s2 _ (@expr.LetIn _ _ _ _ _ _ _)
                           _) _ => default
                        | @expr.App _ _ _ s1 _ #(_)%expr_pat _ | @expr.App _
                          _ _ s1 _ ($_)%expr _ | @expr.App _ _ _ s1 _
                          (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s1 _
                          (@expr.LetIn _ _ _ _ _ _ _) _ => default
                        | _ => default
                        end
                    | None => default
                    end
                | _ => default
                end
            | None => default
            end
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => default
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ => default
    | _ => default
    end
| ident.Z_pow =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_sub =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x - x0)%expr in
    default
| ident.Z_opp =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (- x)%expr in
    default
| ident.Z_div =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x / x0)%expr in
    default
| ident.Z_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x mod x0)%expr in
    default
| ident.Z_log2 =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_log2)%expr @ x)%expr_pat in
    default
| ident.Z_log2_up =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_log2_up)%expr @ x)%expr_pat in
    default
| ident.Z_eqb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_leb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_geb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_geb)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_of_nat =>
    fun x : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Z_of_nat)%expr @ x)%expr_pat in
    default
| ident.Z_to_nat =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_to_nat)%expr @ x)%expr_pat in
    default
| ident.Z_shiftr =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x >> x0)%expr in
    default
| ident.Z_shiftl =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x << x0)%expr in
    default
| ident.Z_land =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x &' x0)%expr in
    default
| ident.Z_lor =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x || x0)%expr in
    default
| ident.Z_bneg =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_bneg)%expr @ x)%expr_pat in
    default
| ident.Z_lnot_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_lnot_modulo)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_mul_split =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat in
    default
| ident.Z_add_get_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            llet default0 := fun 'tt =>
                             llet default0 := fun 'tt =>
                                              llet default0 := fun 'tt =>
                                                               llet default0 := 
                                                               fun 'tt =>
                                                               if
                                                                args =?
                                                                2
                                                                ^ Z.log2 args
                                                               then
                                                                UnderLets.Base
                                                                  (#(ident.fancy_add
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                   (x0, x1))%expr_pat
                                                               else default in
                                                               match x0 with
                                                               | (@expr.App _
                                                                  _ _ s0 _
                                                                  #(idc0)
                                                                  x3 @ x2)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | ident.Z_shiftr =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    _ =>
                                                                    match
                                                                    x2
                                                                    with
                                                                    | #
                                                                    (idc1)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | @ident.Literal
                                                                    t2 v =>
                                                                    match
                                                                    t2 as t3
                                                                    return
                                                                    (base.base_interp
                                                                    t3 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args1 =>
                                                                    match
                                                                    s0 as t2
                                                                    return
                                                                    (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    with
                                                                    | type.base
                                                                    t2 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t3 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args)
                                                                    (- args1))%expr @
                                                                    (x1,
                                                                    x' v))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x3)
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                   | None =>
                                                                    default
                                                                   end
                                                               | (@expr.App _
                                                                  _ _ s0 _
                                                                  ($_)%expr
                                                                  _ @ _)%expr_pat |
                                                                 (@expr.App _
                                                                  _ _ s0 _
                                                                  (@expr.Abs
                                                                   _ _ _ _ _
                                                                   _) _ @ _)%expr_pat |
                                                                 (@expr.App _
                                                                  _ _ s0 _
                                                                  (_ @ _) _ @
                                                                  _)%expr_pat |
                                                                 (@expr.App _
                                                                  _ _ s0 _
                                                                  (@expr.LetIn
                                                                   _ _ _ _ _
                                                                   _ _) _ @ _)%expr_pat =>
                                                                   default
                                                               | (#(_) @ _)%expr_pat |
                                                                 (($_)%expr @
                                                                  _)%expr_pat |
                                                                 (@expr.Abs _
                                                                  _ _ _ _ _ @
                                                                  _)%expr_pat |
                                                                 (@expr.LetIn
                                                                  _ _ _ _ _ _
                                                                  _ @ _)%expr_pat =>
                                                                   default
                                                               | _ =>
                                                                   default0
                                                                    tt
                                                               end in
                                              match x1 with
                                              | (@expr.App _ _ _ s0 _ #
                                                 (idc0) x3 @ x2)%expr_pat =>
                                                  match
                                                    match idc0 with
                                                    | ident.Z_shiftr =>
                                                        Some tt
                                                    | _ => None
                                                    end
                                                  with
                                                  | Some _ =>
                                                      match x2 with
                                                      | #(idc1)%expr_pat =>
                                                          match
                                                            match idc1 with
                                                            | @ident.Literal
                                                              t2 v =>
                                                                match
                                                                  t2 as t3
                                                                  return
                                                                    (base.base_interp
                                                                    t3 ->
                                                                    option Z)
                                                                with
                                                                | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                end v
                                                            | _ => None
                                                            end
                                                          with
                                                          | Some args1 =>
                                                              match
                                                                s0 as t2
                                                                return
                                                                  (Compile.value'
                                                                    false t2 ->
                                                                   UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                              with
                                                              | type.base
                                                                t2 =>
                                                                  fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                  base.try_make_transport_cps
                                                                    (fun
                                                                    t3 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_add
                                                                    (Z.log2
                                                                    args)
                                                                    (- args1))%expr @
                                                                    (x0,
                                                                    x' v))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                              | (s1 -> d1)%ptype =>
                                                                  fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                  => default
                                                              end
                                                                (Compile.reflect
                                                                   x3)
                                                          | None => default
                                                          end
                                                      | _ => default
                                                      end
                                                  | None => default
                                                  end
                                              | (@expr.App _ _ _ s0 _
                                                 ($_)%expr _ @ _)%expr_pat |
                                                (@expr.App _ _ _ s0 _
                                                 (@expr.Abs _ _ _ _ _ _) _ @
                                                 _)%expr_pat |
                                                (@expr.App _ _ _ s0 _ 
                                                 (_ @ _) _ @ _)%expr_pat |
                                                (@expr.App _ _ _ s0 _
                                                 (@expr.LetIn _ _ _ _ _ _ _)
                                                 _ @ _)%expr_pat => default
                                              | (#(_) @ _)%expr_pat |
                                                (($_)%expr @ _)%expr_pat |
                                                (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat |
                                                (@expr.LetIn _ _ _ _ _ _ _ @
                                                 _)%expr_pat => default
                                              | _ => default0 tt
                                              end in
                             match x0 with
                             | (@expr.App _ _ _ s0 _ #(idc0) x3 @ x2)%expr_pat =>
                                 match
                                   match idc0 with
                                   | ident.Z_shiftl => Some tt
                                   | _ => None
                                   end
                                 with
                                 | Some _ =>
                                     match x2 with
                                     | #(idc1)%expr_pat =>
                                         match
                                           match idc1 with
                                           | @ident.Literal t2 v =>
                                               match
                                                 t2 as t3
                                                 return
                                                   (base.base_interp t3 ->
                                                    option Z)
                                               with
                                               | base.type.unit =>
                                                   fun _ : unit => None
                                               | base.type.Z =>
                                                   fun v0 : Z => Some v0
                                               | base.type.bool =>
                                                   fun _ : bool => None
                                               | base.type.nat =>
                                                   fun _ : nat => None
                                               end v
                                           | _ => None
                                           end
                                         with
                                         | Some args1 =>
                                             match
                                               s0 as t2
                                               return
                                                 (Compile.value' false t2 ->
                                                  UnderLets.UnderLets
                                                    base.type ident var
                                                    (defaults.expr
                                                       (type.base
                                                          (base.type.Z *
                                                           base.type.Z)%etype)))
                                             with
                                             | type.base t2 =>
                                                 fun
                                                   v : defaults.expr
                                                         (type.base t2) =>
                                                 base.try_make_transport_cps
                                                   (fun t3 : base.type =>
                                                    defaults.expr
                                                      (type.base t3)) t2
                                                   base.type.Z
                                                   (UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            (base.type.Z *
                                                             base.type.Z)%etype)))
                                                   (fun
                                                      a : option
                                                            (defaults.expr
                                                               (type.base t2) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                    =>
                                                    match a with
                                                    | Some x' =>
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_add
                                                                (Z.log2 args)
                                                                args1)%expr @
                                                            (x1, x' v))%expr_pat
                                                        else default
                                                    | None => default
                                                    end)
                                             | (s1 -> d1)%ptype =>
                                                 fun
                                                   _ : Compile.value' false
                                                         s1 ->
                                                       Compile.value' true d1
                                                 => default
                                             end (Compile.reflect x3)
                                         | None => default
                                         end
                                     | _ => default
                                     end
                                 | None => default
                                 end
                             | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
                               (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _)
                                _ @ _)%expr_pat |
                               (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
                               (@expr.App _ _ _ s0 _
                                (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                                 default
                             | (#(_) @ _)%expr_pat |
                               (($_)%expr @ _)%expr_pat |
                               (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat |
                               (@expr.LetIn _ _ _ _ _ _ _ @ _)%expr_pat =>
                                 default
                             | _ => default0 tt
                             end in
            match x1 with
            | (@expr.App _ _ _ s0 _ #(idc0) x3 @ x2)%expr_pat =>
                match
                  match idc0 with
                  | ident.Z_shiftl => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 2 ^ Z.log2 args
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_add (Z.log2 args)
                                               args1)%expr @ (x0, x' v))%expr_pat
                                       else default
                                   | None => default
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 => default
                            end (Compile.reflect x3)
                        | None => default
                        end
                    | _ => default
                    end
                | None => default
                end
            | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                default
            | (#(_) @ _)%expr_pat | (($_)%expr @ _)%expr_pat |
              (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat |
              (@expr.LetIn _ _ _ _ _ _ _ @ _)%expr_pat => default
            | _ => default0 tt
            end
        | None => default
        end
    | _ => default
    end
| ident.Z_add_with_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat in
    default
| ident.Z_add_with_get_carry =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            llet default0 := fun 'tt =>
                             llet default0 := fun 'tt =>
                                              llet default0 := fun 'tt =>
                                                               llet default0 := 
                                                               fun 'tt =>
                                                               if
                                                                args =?
                                                                2
                                                                ^ Z.log2 args
                                                               then
                                                                UnderLets.Base
                                                                  (#(ident.fancy_addc
                                                                    (Z.log2
                                                                    args) 0)%expr @
                                                                   (x0, x1,
                                                                   x2))%expr_pat
                                                               else default in
                                                               match x1 with
                                                               | (@expr.App _
                                                                  _ _ s0 _
                                                                  #(idc0)
                                                                  x4 @ x3)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | ident.Z_shiftr =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    _ =>
                                                                    match
                                                                    x3
                                                                    with
                                                                    | #
                                                                    (idc1)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | @ident.Literal
                                                                    t2 v =>
                                                                    match
                                                                    t2 as t3
                                                                    return
                                                                    (base.base_interp
                                                                    t3 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args1 =>
                                                                    match
                                                                    s0 as t2
                                                                    return
                                                                    (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    with
                                                                    | type.base
                                                                    t2 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t3 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args)
                                                                    (- args1))%expr @
                                                                    (x0, x2,
                                                                    x' v))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x4)
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | _ =>
                                                                    default
                                                                    end
                                                                   | None =>
                                                                    default
                                                                   end
                                                               | (@expr.App _
                                                                  _ _ s0 _
                                                                  ($_)%expr
                                                                  _ @ _)%expr_pat |
                                                                 (@expr.App _
                                                                  _ _ s0 _
                                                                  (@expr.Abs
                                                                   _ _ _ _ _
                                                                   _) _ @ _)%expr_pat |
                                                                 (@expr.App _
                                                                  _ _ s0 _
                                                                  (_ @ _) _ @
                                                                  _)%expr_pat |
                                                                 (@expr.App _
                                                                  _ _ s0 _
                                                                  (@expr.LetIn
                                                                   _ _ _ _ _
                                                                   _ _) _ @ _)%expr_pat =>
                                                                   default
                                                               | (#(_) @ _)%expr_pat |
                                                                 (($_)%expr @
                                                                  _)%expr_pat |
                                                                 (@expr.Abs _
                                                                  _ _ _ _ _ @
                                                                  _)%expr_pat |
                                                                 (@expr.LetIn
                                                                  _ _ _ _ _ _
                                                                  _ @ _)%expr_pat =>
                                                                   default
                                                               | _ =>
                                                                   default0
                                                                    tt
                                                               end in
                                              match x2 with
                                              | (@expr.App _ _ _ s0 _ #
                                                 (idc0) x4 @ x3)%expr_pat =>
                                                  match
                                                    match idc0 with
                                                    | ident.Z_shiftr =>
                                                        Some tt
                                                    | _ => None
                                                    end
                                                  with
                                                  | Some _ =>
                                                      match x3 with
                                                      | #(idc1)%expr_pat =>
                                                          match
                                                            match idc1 with
                                                            | @ident.Literal
                                                              t2 v =>
                                                                match
                                                                  t2 as t3
                                                                  return
                                                                    (base.base_interp
                                                                    t3 ->
                                                                    option Z)
                                                                with
                                                                | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                end v
                                                            | _ => None
                                                            end
                                                          with
                                                          | Some args1 =>
                                                              match
                                                                s0 as t2
                                                                return
                                                                  (Compile.value'
                                                                    false t2 ->
                                                                   UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                              with
                                                              | type.base
                                                                t2 =>
                                                                  fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                  base.try_make_transport_cps
                                                                    (fun
                                                                    t3 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    if
                                                                    args =?
                                                                    2
                                                                    ^ 
                                                                    Z.log2
                                                                    args
                                                                    then
                                                                    UnderLets.Base
                                                                    (#
                                                                    (ident.fancy_addc
                                                                    (Z.log2
                                                                    args)
                                                                    (- args1))%expr @
                                                                    (x0, x1,
                                                                    x' v))%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                              | (s1 -> d1)%ptype =>
                                                                  fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                  => default
                                                              end
                                                                (Compile.reflect
                                                                   x4)
                                                          | None => default
                                                          end
                                                      | _ => default
                                                      end
                                                  | None => default
                                                  end
                                              | (@expr.App _ _ _ s0 _
                                                 ($_)%expr _ @ _)%expr_pat |
                                                (@expr.App _ _ _ s0 _
                                                 (@expr.Abs _ _ _ _ _ _) _ @
                                                 _)%expr_pat |
                                                (@expr.App _ _ _ s0 _ 
                                                 (_ @ _) _ @ _)%expr_pat |
                                                (@expr.App _ _ _ s0 _
                                                 (@expr.LetIn _ _ _ _ _ _ _)
                                                 _ @ _)%expr_pat => default
                                              | (#(_) @ _)%expr_pat |
                                                (($_)%expr @ _)%expr_pat |
                                                (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat |
                                                (@expr.LetIn _ _ _ _ _ _ _ @
                                                 _)%expr_pat => default
                                              | _ => default0 tt
                                              end in
                             match x1 with
                             | (@expr.App _ _ _ s0 _ #(idc0) x4 @ x3)%expr_pat =>
                                 match
                                   match idc0 with
                                   | ident.Z_shiftl => Some tt
                                   | _ => None
                                   end
                                 with
                                 | Some _ =>
                                     match x3 with
                                     | #(idc1)%expr_pat =>
                                         match
                                           match idc1 with
                                           | @ident.Literal t2 v =>
                                               match
                                                 t2 as t3
                                                 return
                                                   (base.base_interp t3 ->
                                                    option Z)
                                               with
                                               | base.type.unit =>
                                                   fun _ : unit => None
                                               | base.type.Z =>
                                                   fun v0 : Z => Some v0
                                               | base.type.bool =>
                                                   fun _ : bool => None
                                               | base.type.nat =>
                                                   fun _ : nat => None
                                               end v
                                           | _ => None
                                           end
                                         with
                                         | Some args1 =>
                                             match
                                               s0 as t2
                                               return
                                                 (Compile.value' false t2 ->
                                                  UnderLets.UnderLets
                                                    base.type ident var
                                                    (defaults.expr
                                                       (type.base
                                                          (base.type.Z *
                                                           base.type.Z)%etype)))
                                             with
                                             | type.base t2 =>
                                                 fun
                                                   v : defaults.expr
                                                         (type.base t2) =>
                                                 base.try_make_transport_cps
                                                   (fun t3 : base.type =>
                                                    defaults.expr
                                                      (type.base t3)) t2
                                                   base.type.Z
                                                   (UnderLets.UnderLets
                                                      base.type ident var
                                                      (defaults.expr
                                                         (type.base
                                                            (base.type.Z *
                                                             base.type.Z)%etype)))
                                                   (fun
                                                      a : option
                                                            (defaults.expr
                                                               (type.base t2) ->
                                                             defaults.expr
                                                               (type.base
                                                                  base.type.Z))
                                                    =>
                                                    match a with
                                                    | Some x' =>
                                                        if
                                                         args =?
                                                         2 ^ Z.log2 args
                                                        then
                                                         UnderLets.Base
                                                           (#(ident.fancy_addc
                                                                (Z.log2 args)
                                                                args1)%expr @
                                                            (x0, x2, x' v))%expr_pat
                                                        else default
                                                    | None => default
                                                    end)
                                             | (s1 -> d1)%ptype =>
                                                 fun
                                                   _ : Compile.value' false
                                                         s1 ->
                                                       Compile.value' true d1
                                                 => default
                                             end (Compile.reflect x4)
                                         | None => default
                                         end
                                     | _ => default
                                     end
                                 | None => default
                                 end
                             | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
                               (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _)
                                _ @ _)%expr_pat |
                               (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
                               (@expr.App _ _ _ s0 _
                                (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                                 default
                             | (#(_) @ _)%expr_pat |
                               (($_)%expr @ _)%expr_pat |
                               (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat |
                               (@expr.LetIn _ _ _ _ _ _ _ @ _)%expr_pat =>
                                 default
                             | _ => default0 tt
                             end in
            match x2 with
            | (@expr.App _ _ _ s0 _ #(idc0) x4 @ x3)%expr_pat =>
                match
                  match idc0 with
                  | ident.Z_shiftl => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match x3 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 2 ^ Z.log2 args
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_addc (Z.log2 args)
                                               args1)%expr @ (x0, x1, x' v))%expr_pat
                                       else default
                                   | None => default
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 => default
                            end (Compile.reflect x4)
                        | None => default
                        end
                    | _ => default
                    end
                | None => default
                end
            | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                default
            | (#(_) @ _)%expr_pat | (($_)%expr @ _)%expr_pat |
              (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat |
              (@expr.LetIn _ _ _ _ _ _ _ @ _)%expr_pat => default
            | _ => default0 tt
            end
        | None => default
        end
    | _ => default
    end
| ident.Z_sub_get_borrow =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            llet default0 := fun 'tt =>
                             if args =? 2 ^ Z.log2 args
                             then
                              UnderLets.Base
                                (#(ident.fancy_sub (Z.log2 args) 0)%expr @
                                 (x0, x1))%expr_pat
                             else default in
            match x1 with
            | (@expr.App _ _ _ s0 _ #(idc0) x3 @ x2)%expr_pat =>
                match
                  match idc0 with
                  | ident.Z_shiftl => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match x2 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 2 ^ Z.log2 args
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_sub (Z.log2 args)
                                               args1)%expr @ (x0, x' v))%expr_pat
                                       else default
                                   | None => default
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 => default
                            end (Compile.reflect x3)
                        | None => default
                        end
                    | _ => default
                    end
                | None =>
                    match
                      match idc0 with
                      | ident.Z_shiftr => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x2 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_sub
                                                   (Z.log2 args) (- args1))%expr @
                                               (x0, x' v))%expr_pat
                                           else default
                                       | None => default
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 => default
                                end (Compile.reflect x3)
                            | None => default
                            end
                        | _ => default
                        end
                    | None => default
                    end
                end
            | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                default
            | (#(_) @ _)%expr_pat | (($_)%expr @ _)%expr_pat |
              (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat |
              (@expr.LetIn _ _ _ _ _ _ _ @ _)%expr_pat => default
            | _ => default0 tt
            end
        | None => default
        end
    | _ => default
    end
| ident.Z_sub_with_get_borrow =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            llet default0 := fun 'tt =>
                             if args =? 2 ^ Z.log2 args
                             then
                              UnderLets.Base
                                (#(ident.fancy_subb (Z.log2 args) 0)%expr @
                                 (x0, x1, x2))%expr_pat
                             else default in
            match x2 with
            | (@expr.App _ _ _ s0 _ #(idc0) x4 @ x3)%expr_pat =>
                match
                  match idc0 with
                  | ident.Z_shiftl => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match x3 with
                    | #(idc1)%expr_pat =>
                        match
                          match idc1 with
                          | @ident.Literal t2 v =>
                              match
                                t2 as t3
                                return (base.base_interp t3 -> option Z)
                              with
                              | base.type.unit => fun _ : unit => None
                              | base.type.Z => fun v0 : Z => Some v0
                              | base.type.bool => fun _ : bool => None
                              | base.type.nat => fun _ : nat => None
                              end v
                          | _ => None
                          end
                        with
                        | Some args1 =>
                            match
                              s0 as t2
                              return
                                (Compile.value' false t2 ->
                                 UnderLets.UnderLets base.type ident var
                                   (defaults.expr
                                      (type.base
                                         (base.type.Z * base.type.Z)%etype)))
                            with
                            | type.base t2 =>
                                fun v : defaults.expr (type.base t2) =>
                                base.try_make_transport_cps
                                  (fun t3 : base.type =>
                                   defaults.expr (type.base t3)) t2
                                  base.type.Z
                                  (UnderLets.UnderLets base.type ident var
                                     (defaults.expr
                                        (type.base
                                           (base.type.Z * base.type.Z)%etype)))
                                  (fun
                                     a : option
                                           (defaults.expr (type.base t2) ->
                                            defaults.expr
                                              (type.base base.type.Z)) =>
                                   match a with
                                   | Some x' =>
                                       if args =? 2 ^ Z.log2 args
                                       then
                                        UnderLets.Base
                                          (#(ident.fancy_subb (Z.log2 args)
                                               args1)%expr @ (x0, x1, x' v))%expr_pat
                                       else default
                                   | None => default
                                   end)
                            | (s1 -> d1)%ptype =>
                                fun
                                  _ : Compile.value' false s1 ->
                                      Compile.value' true d1 => default
                            end (Compile.reflect x4)
                        | None => default
                        end
                    | _ => default
                    end
                | None =>
                    match
                      match idc0 with
                      | ident.Z_shiftr => Some tt
                      | _ => None
                      end
                    with
                    | Some _ =>
                        match x3 with
                        | #(idc1)%expr_pat =>
                            match
                              match idc1 with
                              | @ident.Literal t2 v =>
                                  match
                                    t2 as t3
                                    return (base.base_interp t3 -> option Z)
                                  with
                                  | base.type.unit => fun _ : unit => None
                                  | base.type.Z => fun v0 : Z => Some v0
                                  | base.type.bool => fun _ : bool => None
                                  | base.type.nat => fun _ : nat => None
                                  end v
                              | _ => None
                              end
                            with
                            | Some args1 =>
                                match
                                  s0 as t2
                                  return
                                    (Compile.value' false t2 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t2 =>
                                    fun v : defaults.expr (type.base t2) =>
                                    base.try_make_transport_cps
                                      (fun t3 : base.type =>
                                       defaults.expr (type.base t3)) t2
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a : option
                                               (defaults.expr (type.base t2) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                       match a with
                                       | Some x' =>
                                           if args =? 2 ^ Z.log2 args
                                           then
                                            UnderLets.Base
                                              (#(ident.fancy_subb
                                                   (Z.log2 args) (- args1))%expr @
                                               (x0, x1, x' v))%expr_pat
                                           else default
                                       | None => default
                                       end)
                                | (s1 -> d1)%ptype =>
                                    fun
                                      _ : Compile.value' false s1 ->
                                          Compile.value' true d1 => default
                                end (Compile.reflect x4)
                            | None => default
                            end
                        | _ => default
                        end
                    | None => default
                    end
                end
            | (@expr.App _ _ _ s0 _ ($_)%expr _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (_ @ _) _ @ _)%expr_pat |
              (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ @ _)%expr_pat =>
                default
            | (#(_) @ _)%expr_pat | (($_)%expr @ _)%expr_pat |
              (@expr.Abs _ _ _ _ _ _ @ _)%expr_pat |
              (@expr.LetIn _ _ _ _ _ _ _ @ _)%expr_pat => default
            | _ => default0 tt
            end
        | None => default
        end
    | _ => default
    end
| ident.Z_zselect =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat in
    llet default0 := fun 'tt =>
                     UnderLets.Base
                       (#(ident.fancy_selc)%expr @ (x, x0, x1))%expr_pat in
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x3) x2 =>
        match match idc with
              | ident.Z_cc_m => Some tt
              | _ => None
              end with
        | Some _ =>
            match x3 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if args0 =? 2 ^ Z.log2 args0
                               then
                                UnderLets.Base
                                  (#(ident.fancy_selm (Z.log2 args0))%expr @
                                   (x' v, x0, x1))%expr_pat
                               else default
                           | None => default
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 => default
                    end (Compile.reflect x2)
                | None => default
                end
            | _ => default
            end
        | None =>
            match
              match idc with
              | ident.Z_land => Some tt
              | _ => None
              end
            with
            | Some _ =>
                llet default1 := fun 'tt =>
                                 match x2 with
                                 | #(idc0)%expr_pat =>
                                     match
                                       match idc0 with
                                       | @ident.Literal t1 v =>
                                           match
                                             t1 as t2
                                             return
                                               (base.base_interp t2 ->
                                                option Z)
                                           with
                                           | base.type.unit =>
                                               fun _ : unit => None
                                           | base.type.Z =>
                                               fun v0 : Z => Some v0
                                           | base.type.bool =>
                                               fun _ : bool => None
                                           | base.type.nat =>
                                               fun _ : nat => None
                                           end v
                                       | _ => None
                                       end
                                     with
                                     | Some args0 =>
                                         match
                                           s0 as t2
                                           return
                                             (Compile.value' false t2 ->
                                              UnderLets.UnderLets base.type
                                                ident var
                                                (defaults.expr
                                                   (type.base base.type.Z)))
                                         with
                                         | type.base t2 =>
                                             fun
                                               v : defaults.expr
                                                     (type.base t2) =>
                                             base.try_make_transport_cps
                                               (fun t1 : base.type =>
                                                defaults.expr (type.base t1))
                                               t2 base.type.Z
                                               (UnderLets.UnderLets base.type
                                                  ident var
                                                  (defaults.expr
                                                     (type.base base.type.Z)))
                                               (fun
                                                  a : option
                                                        (defaults.expr
                                                           (type.base t2) ->
                                                         defaults.expr
                                                           (type.base
                                                              base.type.Z))
                                                =>
                                                match a with
                                                | Some x' =>
                                                    if args0 =? 1
                                                    then
                                                     UnderLets.Base
                                                       (#(ident.fancy_sell)%expr @
                                                        (x' v, x0, x1))%expr_pat
                                                    else default
                                                | None => default
                                                end)
                                         | (s1 -> d1)%ptype =>
                                             fun
                                               _ : Compile.value' false s1 ->
                                                   Compile.value' true d1 =>
                                             default
                                         end (Compile.reflect x3)
                                     | None => default
                                     end
                                 | _ => default
                                 end in
                match x3 with
                | #(idc0)%expr_pat =>
                    match
                      match idc0 with
                      | @ident.Literal t1 v =>
                          match
                            t1 as t2 return (base.base_interp t2 -> option Z)
                          with
                          | base.type.unit => fun _ : unit => None
                          | base.type.Z => fun v0 : Z => Some v0
                          | base.type.bool => fun _ : bool => None
                          | base.type.nat => fun _ : nat => None
                          end v
                      | _ => None
                      end
                    with
                    | Some args0 =>
                        match
                          s as t2
                          return
                            (Compile.value' false t2 ->
                             UnderLets.UnderLets base.type ident var
                               (defaults.expr (type.base base.type.Z)))
                        with
                        | type.base t2 =>
                            fun v : defaults.expr (type.base t2) =>
                            base.try_make_transport_cps
                              (fun t1 : base.type =>
                               defaults.expr (type.base t1)) t2 base.type.Z
                              (UnderLets.UnderLets base.type ident var
                                 (defaults.expr (type.base base.type.Z)))
                              (fun
                                 a : option
                                       (defaults.expr (type.base t2) ->
                                        defaults.expr (type.base base.type.Z))
                               =>
                               match a with
                               | Some x' =>
                                   if args0 =? 1
                                   then
                                    UnderLets.Base
                                      (#(ident.fancy_sell)%expr @
                                       (x' v, x0, x1))%expr_pat
                                   else default
                               | None => default
                               end)
                        | (s1 -> d1)%ptype =>
                            fun
                              _ : Compile.value' false s1 ->
                                  Compile.value' true d1 => default
                        end (Compile.reflect x2)
                    | None => default1 tt
                    end
                | _ => default1 tt
                end
            | None => default
            end
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => default
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ => default
    | _ => default0 tt
    end
| ident.Z_add_modulo =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet _ := UnderLets.Base
                (#(ident.Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat in
    UnderLets.Base (#(ident.fancy_addm)%expr @ (x, x0, x1))%expr_pat
| ident.Z_rshi =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            match x2 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    if args =? 2 ^ Z.log2 args
                    then
                     UnderLets.Base
                       (#(ident.fancy_rshi (Z.log2 args) args0)%expr @
                        (x0, x1))%expr_pat
                    else default
                | None => default
                end
            | _ => default
            end
        | None => default
        end
    | _ => default
    end
| ident.Z_cc_m =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_cc_m)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_cast range =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_cast range)%expr @ x)%expr_pat in
    default
| ident.Z_cast2 range =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat in
    default
| ident.fancy_add log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat in
    default
| ident.fancy_addc log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat in
    default
| ident.fancy_sub log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat in
    default
| ident.fancy_subb log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat in
    default
| ident.fancy_mulll log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat in
    default
| ident.fancy_mullh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat in
    default
| ident.fancy_mulhl log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat in
    default
| ident.fancy_mulhh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat in
    default
| ident.fancy_rshi log2wordmax x =>
    fun x0 : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat in
    default
| ident.fancy_selc =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat in
    default
| ident.fancy_selm log2wordmax =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat in
    default
| ident.fancy_sell =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat in
    default
| ident.fancy_addm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat in
    default
end
     : Compile.value' true t
