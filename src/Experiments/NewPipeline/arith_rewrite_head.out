arith_rewrite_head = 
match idc in (ident t) return (Compile.value' true t) with
| @ident.Literal t v =>
    match
      t as t0
      return
        (base.base_interp t0 ->
         UnderLets.UnderLets base.type ident var
           (defaults.expr (type.base t0)))
    with
    | base.type.unit =>
        fun v0 : unit => llet default := UnderLets.Base ##(v0)%expr in
        default
    | base.type.Z =>
        fun v0 : Z => llet default := UnderLets.Base ##(v0)%expr in
        default
    | base.type.bool =>
        fun v0 : bool => llet default := UnderLets.Base ##(v0)%expr in
        default
    | base.type.nat =>
        fun v0 : nat => llet default := UnderLets.Base ##(v0)%expr in
        default
    end v
| ident.Nat_succ =>
    fun x : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_succ)%expr @ x)%expr_pat in
    default
| ident.Nat_pred =>
    fun x : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_pred)%expr @ x)%expr_pat in
    default
| ident.Nat_max =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_max)%expr @ x @ x0)%expr_pat in
    default
| ident.Nat_mul =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_mul)%expr @ x @ x0)%expr_pat in
    default
| ident.Nat_add =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_add)%expr @ x @ x0)%expr_pat in
    default
| ident.Nat_sub =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Nat_sub)%expr @ x @ x0)%expr_pat in
    default
| @ident.nil t => llet default := UnderLets.Base []%expr_pat in
    default
| @ident.cons t =>
    fun (x : defaults.expr (type.base t))
      (x0 : defaults.expr (type.base (base.type.list t))) =>
    llet default := UnderLets.Base (x :: x0)%expr_pat in
    default
| @ident.pair A B =>
    fun (x : defaults.expr (type.base A)) (x0 : defaults.expr (type.base B))
    => llet default := UnderLets.Base (x, x0)%expr_pat in
    default
| @ident.fst A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    llet default := UnderLets.Base (#(ident.fst)%expr @ x)%expr_pat in
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x1) x0 =>
        match
          match idc with
          | @ident.pair A0 B0 => Some (A0, B0)
          | _ => None
          end
        with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (defaults.expr (type.base A)))
            with
            | type.base t2 =>
                fun v : defaults.expr (type.base t2) =>
                match
                  s as t3
                  return
                    (Compile.value' false t3 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base A)))
                with
                | type.base t3 =>
                    fun _ : defaults.expr (type.base t3) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t2
                      A
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base A)))
                      (fun
                         a : option
                               (defaults.expr (type.base t2) ->
                                defaults.expr (type.base A)) =>
                       match a with
                       | Some x' => UnderLets.Base (x' v)
                       | None => default
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => default
                end (Compile.reflect x0)
            | (s1 -> d1)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d1 =>
                default
            end (Compile.reflect x1)
        | None => default
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => default
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ => default
    | _ => default
    end
| @ident.snd A B =>
    fun x : defaults.expr (type.base (A * B)%etype) =>
    llet default := UnderLets.Base (#(ident.snd)%expr @ x)%expr_pat in
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x1) x0 =>
        match
          match idc with
          | @ident.pair A0 B0 => Some (A0, B0)
          | _ => None
          end
        with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (defaults.expr (type.base B)))
            with
            | type.base t2 =>
                fun _ : defaults.expr (type.base t2) =>
                match
                  s as t3
                  return
                    (Compile.value' false t3 ->
                     UnderLets.UnderLets base.type ident var
                       (defaults.expr (type.base B)))
                with
                | type.base t3 =>
                    fun v0 : defaults.expr (type.base t3) =>
                    base.try_make_transport_cps
                      (fun t0 : base.type => defaults.expr (type.base t0)) t3
                      B
                      (UnderLets.UnderLets base.type ident var
                         (defaults.expr (type.base B)))
                      (fun
                         a : option
                               (defaults.expr (type.base t3) ->
                                defaults.expr (type.base B)) =>
                       match a with
                       | Some x' => UnderLets.Base (x' v0)
                       | None => default
                       end)
                | (s1 -> d1)%ptype =>
                    fun _ : Compile.value' false s1 -> Compile.value' true d1
                    => default
                end (Compile.reflect x0)
            | (s1 -> d1)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d1 =>
                default
            end (Compile.reflect x1)
        | None => default
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => default
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ => default
    | _ => default
    end
| @ident.prod_rect A B T =>
    fun
      (x : defaults.expr (type.base A) ->
           defaults.expr (type.base B) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base T)))
      (x0 : defaults.expr (type.base (A * B)%etype)) =>
    llet default := UnderLets.Base
                      (#(ident.prod_rect)%expr @
                       (λ (x1 : var (type.base A))(x2 : var (type.base B)),
                        UnderLets.to_expr (x ($x1) ($x2)))%expr @ x0)%expr_pat in
    default
| @ident.bool_rect T =>
    fun
      (x
       x0 : defaults.expr (type.base base.type.unit) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base base.type.bool)) =>
    llet default := UnderLets.Base
                      (#(ident.bool_rect)%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x2)))%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat in
    default
| @ident.nat_rect P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    llet default := UnderLets.Base
                      (#(ident.nat_rect)%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x2)))%expr @
                       (λ (x2 : var (type.base base.type.nat))(x3 : var
                                                                    (type.base
                                                                    P)),
                        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat in
    default
| @ident.nat_rect_arrow P Q =>
    fun
      (x : defaults.expr (type.base P) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base Q)))
      (x0 : defaults.expr (type.base base.type.nat) ->
            (defaults.expr (type.base P) ->
             UnderLets.UnderLets base.type ident var
               (defaults.expr (type.base Q))) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base Q)))
      (x1 : defaults.expr (type.base base.type.nat))
      (x2 : defaults.expr (type.base P)) =>
    llet default := UnderLets.Base
                      (#(ident.nat_rect_arrow)%expr @
                       (λ x3 : var (type.base P),
                        UnderLets.to_expr (x ($x3)))%expr @
                       (λ (x3 : var (type.base base.type.nat))(x4 : var
                                                                    (type.base
                                                                    P ->
                                                                    type.base
                                                                    Q)%ptype)
                        (x5 : var (type.base P)),
                        UnderLets.to_expr
                          (x0 ($x3)
                             (fun x6 : defaults.expr (type.base P) =>
                              UnderLets.Base ($x4 @ x6)%expr_pat) ($x5)))%expr @
                       x1 @ x2)%expr_pat in
    default
| @ident.list_rect A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            defaults.expr (type.base P) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.list_rect)%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x2)))%expr @
                       (λ (x2 : var (type.base A))(x3 : var
                                                          (type.base
                                                             (base.type.list
                                                                A)))(x4 : 
                                                                    var
                                                                    (type.base
                                                                    P)),
                        UnderLets.to_expr (x0 ($x2) ($x3) ($x4)))%expr @ x1)%expr_pat in
    default
| @ident.list_case A P =>
    fun
      (x : defaults.expr (type.base base.type.unit) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base P)))
      (x0 : defaults.expr (type.base A) ->
            defaults.expr (type.base (base.type.list A)) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base P)))
      (x1 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.list_case)%expr @
                       (λ x2 : var (type.base base.type.unit),
                        UnderLets.to_expr (x ($x2)))%expr @
                       (λ (x2 : var (type.base A))(x3 : var
                                                          (type.base
                                                             (base.type.list
                                                                A))),
                        UnderLets.to_expr (x0 ($x2) ($x3)))%expr @ x1)%expr_pat in
    default
| @ident.List_length T =>
    fun x : defaults.expr (type.base (base.type.list T)) =>
    llet default := UnderLets.Base (#(ident.List_length)%expr @ x)%expr_pat in
    default
| ident.List_seq =>
    fun x x0 : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.List_seq)%expr @ x @ x0)%expr_pat in
    default
| @ident.List_firstn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.List_firstn)%expr @ x @ x0)%expr_pat in
    default
| @ident.List_skipn A =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.List_skipn)%expr @ x @ x0)%expr_pat in
    default
| @ident.List_repeat A =>
    fun (x : defaults.expr (type.base A))
      (x0 : defaults.expr (type.base base.type.nat)) =>
    llet default := UnderLets.Base
                      (#(ident.List_repeat)%expr @ x @ x0)%expr_pat in
    default
| @ident.List_combine A B =>
    fun (x : defaults.expr (type.base (base.type.list A)))
      (x0 : defaults.expr (type.base (base.type.list B))) =>
    llet default := UnderLets.Base
                      (#(ident.List_combine)%expr @ x @ x0)%expr_pat in
    default
| @ident.List_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base B)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.List_map)%expr @
                       (λ x1 : var (type.base A),
                        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat in
    default
| @ident.List_app A =>
    fun x x0 : defaults.expr (type.base (base.type.list A)) =>
    llet default := UnderLets.Base (x ++ x0)%expr in
    default
| @ident.List_rev A =>
    fun x : defaults.expr (type.base (base.type.list A)) =>
    llet default := UnderLets.Base (#(ident.List_rev)%expr @ x)%expr_pat in
    default
| @ident.List_flat_map A B =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base (base.type.list B))))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.List_flat_map)%expr @
                       (λ x1 : var (type.base A),
                        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat in
    default
| @ident.List_partition A =>
    fun
      (x : defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base base.type.bool)))
      (x0 : defaults.expr (type.base (base.type.list A))) =>
    llet default := UnderLets.Base
                      (#(ident.List_partition)%expr @
                       (λ x1 : var (type.base A),
                        UnderLets.to_expr (x ($x1)))%expr @ x0)%expr_pat in
    default
| @ident.List_fold_right A B =>
    fun
      (x : defaults.expr (type.base B) ->
           defaults.expr (type.base A) ->
           UnderLets.UnderLets base.type ident var
             (defaults.expr (type.base A)))
      (x0 : defaults.expr (type.base A))
      (x1 : defaults.expr (type.base (base.type.list B))) =>
    llet default := UnderLets.Base
                      (#(ident.List_fold_right)%expr @
                       (λ (x2 : var (type.base B))(x3 : var (type.base A)),
                        UnderLets.to_expr (x ($x2) ($x3)))%expr @ x0 @ x1)%expr_pat in
    default
| @ident.List_update_nth T =>
    fun (x : defaults.expr (type.base base.type.nat))
      (x0 : defaults.expr (type.base T) ->
            UnderLets.UnderLets base.type ident var
              (defaults.expr (type.base T)))
      (x1 : defaults.expr (type.base (base.type.list T))) =>
    llet default := UnderLets.Base
                      (#(ident.List_update_nth)%expr @ x @
                       (λ x2 : var (type.base T),
                        UnderLets.to_expr (x0 ($x2)))%expr @ x1)%expr_pat in
    default
| @ident.List_nth_default T =>
    fun (x : defaults.expr (type.base T))
      (x0 : defaults.expr (type.base (base.type.list T)))
      (x1 : defaults.expr (type.base base.type.nat)) =>
    llet default := UnderLets.Base
                      (#(ident.List_nth_default)%expr @ x @ x0 @ x1)%expr_pat in
    default
| ident.Z_add =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x + x0)%expr in
    llet default0 := fun 'tt =>
                     llet default0 := fun 'tt =>
                                      llet default0 := fun 'tt =>
                                                       match x0 with
                                                       | @expr.App _ _ _ s _
                                                         #(idc)%expr_pat
                                                         x1 =>
                                                           match
                                                             match idc with
                                                             | ident.Z_opp =>
                                                                 Some tt
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some _ =>
                                                               match
                                                                 s as t2
                                                                 return
                                                                   (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                               with
                                                               | type.base
                                                                 t2 =>
                                                                   fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                   base.try_make_transport_cps
                                                                    (fun
                                                                    t0 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t0)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    UnderLets.Base
                                                                    (x - x' v)%expr
                                                                    | None =>
                                                                    default
                                                                    end)
                                                               | (s0 -> d0)%ptype =>
                                                                   fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                                   => default
                                                               end
                                                                 (Compile.reflect
                                                                    x1)
                                                           | None => default
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         ($_)%expr _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.Abs _ _ _ _ _
                                                          _) _ | @expr.App _
                                                         _ _ s _
                                                         (_ @ _)%expr_pat _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.LetIn _ _ _ _
                                                          _ _ _) _ => default
                                                       | _ => default
                                                       end in
                                      match x with
                                      | @expr.App _ _ _ s _ #(idc)%expr_pat
                                        x1 =>
                                          match
                                            match idc with
                                            | ident.Z_opp => Some tt
                                            | _ => None
                                            end
                                          with
                                          | Some _ =>
                                              match
                                                s as t2
                                                return
                                                  (Compile.value' false t2 ->
                                                   UnderLets.UnderLets
                                                     base.type ident var
                                                     (defaults.expr
                                                        (type.base
                                                           base.type.Z)))
                                              with
                                              | type.base t2 =>
                                                  fun
                                                    v : defaults.expr
                                                          (type.base t2) =>
                                                  base.try_make_transport_cps
                                                    (fun t0 : base.type =>
                                                     defaults.expr
                                                       (type.base t0)) t2
                                                    base.type.Z
                                                    (UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                    (fun
                                                       a : option
                                                             (defaults.expr
                                                                (type.base t2) ->
                                                              defaults.expr
                                                                (type.base
                                                                   base.type.Z))
                                                     =>
                                                     match a with
                                                     | Some x' =>
                                                         UnderLets.Base
                                                           (x0 - x' v)%expr
                                                     | None => default
                                                     end)
                                              | (s0 -> d0)%ptype =>
                                                  fun
                                                    _ : Compile.value' false
                                                          s0 ->
                                                        Compile.value' true
                                                          d0 => default
                                              end (Compile.reflect x1)
                                          | None => default
                                          end
                                      | @expr.App _ _ _ s _ ($_)%expr _ |
                                        @expr.App _ _ _ s _
                                        (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                                        _ _ _ s _ (_ @ _)%expr_pat _ |
                                        @expr.App _ _ _ s _
                                        (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                          default
                                      | _ => default0 tt
                                      end in
                     match x0 with
                     | #(idc)%expr_pat =>
                         match
                           match idc with
                           | @ident.Literal t0 v =>
                               match
                                 t0 as t1
                                 return (base.base_interp t1 -> option Z)
                               with
                               | base.type.unit => fun _ : unit => None
                               | base.type.Z => fun v0 : Z => Some v0
                               | base.type.bool => fun _ : bool => None
                               | base.type.nat => fun _ : nat => None
                               end v
                           | _ => None
                           end
                         with
                         | Some args =>
                             if args =? 0
                             then UnderLets.Base x
                             else
                              match x with
                              | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                                  match
                                    match idc0 with
                                    | ident.Z_opp => Some tt
                                    | _ => None
                                    end
                                  with
                                  | Some _ =>
                                      match
                                        s as t2
                                        return
                                          (Compile.value' false t2 ->
                                           UnderLets.UnderLets base.type
                                             ident var
                                             (defaults.expr
                                                (type.base base.type.Z)))
                                      with
                                      | type.base t2 =>
                                          fun
                                            v : defaults.expr (type.base t2)
                                          =>
                                          base.try_make_transport_cps
                                            (fun t1 : base.type =>
                                             defaults.expr (type.base t1)) t2
                                            base.type.Z
                                            (UnderLets.UnderLets base.type
                                               ident var
                                               (defaults.expr
                                                  (type.base base.type.Z)))
                                            (fun
                                               a : option
                                                     (defaults.expr
                                                        (type.base t2) ->
                                                      defaults.expr
                                                        (type.base
                                                           base.type.Z)) =>
                                             match a with
                                             | Some x' =>
                                                 if args >? 0
                                                 then
                                                  UnderLets.Base
                                                    (##(args) - x' v)%expr
                                                 else
                                                  match
                                                    s as t3
                                                    return
                                                      (Compile.value' false
                                                         t3 ->
                                                       UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                  with
                                                  | type.base t3 =>
                                                      fun
                                                        v0 : defaults.expr
                                                               (type.base t3)
                                                      =>
                                                      base.try_make_transport_cps
                                                        (fun t1 : base.type
                                                         =>
                                                         defaults.expr
                                                           (type.base t1)) t3
                                                        base.type.Z
                                                        (UnderLets.UnderLets
                                                           base.type ident
                                                           var
                                                           (defaults.expr
                                                              (type.base
                                                                 base.type.Z)))
                                                        (fun
                                                           a0 : option
                                                                  (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                   defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                         =>
                                                         match a0 with
                                                         | Some x'0 =>
                                                             if args <? 0
                                                             then
                                                              UnderLets.Base
                                                                (-
                                                                 (x'0 v0 +
                                                                  ##((- args)%Z)))%expr
                                                             else default
                                                         | None => default
                                                         end)
                                                  | (s0 -> d0)%ptype =>
                                                      fun
                                                        _ : Compile.value'
                                                              false s0 ->
                                                            Compile.value'
                                                              true d0 =>
                                                      default
                                                  end (Compile.reflect x1)
                                             | None => default
                                             end)
                                      | (s0 -> d0)%ptype =>
                                          fun
                                            _ : Compile.value' false s0 ->
                                                Compile.value' true d0 =>
                                          default
                                      end (Compile.reflect x1)
                                  | None => default
                                  end
                              | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _
                                _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                                _ _ _ s _ (_ @ _)%expr_pat _ | @expr.App _ _
                                _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                  default
                              | _ => default
                              end
                         | None => default0 tt
                         end
                     | @expr.App _ _ _ s _ #(idc)%expr_pat x1 =>
                         match
                           match idc with
                           | ident.Z_opp => Some tt
                           | _ => None
                           end
                         with
                         | Some _ =>
                             match x with
                             | #(idc0)%expr_pat =>
                                 match
                                   match idc0 with
                                   | @ident.Literal t1 v =>
                                       match
                                         t1 as t2
                                         return
                                           (base.base_interp t2 -> option Z)
                                       with
                                       | base.type.unit =>
                                           fun _ : unit => None
                                       | base.type.Z => fun v0 : Z => Some v0
                                       | base.type.bool =>
                                           fun _ : bool => None
                                       | base.type.nat => fun _ : nat => None
                                       end v
                                   | _ => None
                                   end
                                 with
                                 | Some args0 =>
                                     match
                                       s as t2
                                       return
                                         (Compile.value' false t2 ->
                                          UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base base.type.Z)))
                                     with
                                     | type.base t2 =>
                                         fun v : defaults.expr (type.base t2)
                                         =>
                                         base.try_make_transport_cps
                                           (fun t1 : base.type =>
                                            defaults.expr (type.base t1)) t2
                                           base.type.Z
                                           (UnderLets.UnderLets base.type
                                              ident var
                                              (defaults.expr
                                                 (type.base base.type.Z)))
                                           (fun
                                              a : option
                                                    (defaults.expr
                                                       (type.base t2) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                            =>
                                            match a with
                                            | Some x' =>
                                                if args0 >? 0
                                                then
                                                 UnderLets.Base
                                                   (##(args0) - x' v)%expr
                                                else
                                                 match
                                                   s as t3
                                                   return
                                                     (Compile.value' false t3 ->
                                                      UnderLets.UnderLets
                                                        base.type ident var
                                                        (defaults.expr
                                                           (type.base
                                                              base.type.Z)))
                                                 with
                                                 | type.base t3 =>
                                                     fun
                                                       v0 : defaults.expr
                                                              (type.base t3)
                                                     =>
                                                     base.try_make_transport_cps
                                                       (fun t1 : base.type =>
                                                        defaults.expr
                                                          (type.base t1)) t3
                                                       base.type.Z
                                                       (UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                       (fun
                                                          a0 : option
                                                                 (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                  defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                        =>
                                                        match a0 with
                                                        | Some x'0 =>
                                                            if args0 <? 0
                                                            then
                                                             UnderLets.Base
                                                               (-
                                                                (##((- args0)%Z) +
                                                                 x'0 v0))%expr
                                                            else default
                                                        | None => default
                                                        end)
                                                 | (s0 -> d0)%ptype =>
                                                     fun
                                                       _ : Compile.value'
                                                             false s0 ->
                                                           Compile.value'
                                                             true d0 =>
                                                     default
                                                 end (Compile.reflect x1)
                                            | None => default
                                            end)
                                     | (s0 -> d0)%ptype =>
                                         fun
                                           _ : Compile.value' false s0 ->
                                               Compile.value' true d0 =>
                                         default
                                     end (Compile.reflect x1)
                                 | None => default
                                 end
                             | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x2 =>
                                 match
                                   match idc0 with
                                   | ident.Z_opp => Some tt
                                   | _ => None
                                   end
                                 with
                                 | Some _ =>
                                     match
                                       s0 as t2
                                       return
                                         (Compile.value' false t2 ->
                                          UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base base.type.Z)))
                                     with
                                     | type.base t2 =>
                                         fun v : defaults.expr (type.base t2)
                                         =>
                                         base.try_make_transport_cps
                                           (fun t1 : base.type =>
                                            defaults.expr (type.base t1)) t2
                                           base.type.Z
                                           (UnderLets.UnderLets base.type
                                              ident var
                                              (defaults.expr
                                                 (type.base base.type.Z)))
                                           (fun
                                              a : option
                                                    (defaults.expr
                                                       (type.base t2) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                            =>
                                            match a with
                                            | Some x' =>
                                                match
                                                  s as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             base.type.Z)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t1 : base.type =>
                                                       defaults.expr
                                                         (type.base t1)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               base.type.Z)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           UnderLets.Base
                                                             (-
                                                              (x' v + x'0 v0))%expr
                                                       | None => default
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 => default
                                                end (Compile.reflect x1)
                                            | None => default
                                            end)
                                     | (s1 -> d1)%ptype =>
                                         fun
                                           _ : Compile.value' false s1 ->
                                               Compile.value' true d1 =>
                                         default
                                     end (Compile.reflect x2)
                                 | None => default
                                 end
                             | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _
                               _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                               _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _
                               _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                 default
                             | _ => default
                             end
                         | None => default
                         end
                     | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
                       (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
                       (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                       (@expr.LetIn _ _ _ _ _ _ _) _ => default
                     | _ => default0 tt
                     end in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args => if args =? 0 then UnderLets.Base x0 else default
        | None => default0 tt
        end
    | _ => default0 tt
    end
| ident.Z_mul =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x * x0)%expr in
    llet default0 := fun 'tt =>
                     llet default0 := fun 'tt =>
                                      llet default0 := fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       match x with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if
                                                                (args =?
                                                                 2
                                                                 ^ Z.log2
                                                                    args) &&
                                                                negb
                                                                  (args =? 2)
                                                               then
                                                                UnderLets.Base
                                                                  (x0 <<
                                                                   ##
                                                                   (Z.log2
                                                                    args))%expr
                                                               else default
                                                           | None => default
                                                           end
                                                       | _ => default
                                                       end in
                                                       match x0 with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if
                                                                (args =?
                                                                 2
                                                                 ^ Z.log2
                                                                    args) &&
                                                                negb
                                                                  (args =? 2)
                                                               then
                                                                UnderLets.Base
                                                                  (x <<
                                                                   ##
                                                                   (Z.log2
                                                                    args))%expr
                                                               else default
                                                           | None =>
                                                               default0 tt
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         #(idc)%expr_pat
                                                         x1 =>
                                                           match
                                                             match idc with
                                                             | ident.Z_opp =>
                                                                 Some tt
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some _ =>
                                                               match
                                                                 s as t2
                                                                 return
                                                                   (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                               with
                                                               | type.base
                                                                 t2 =>
                                                                   fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                   base.try_make_transport_cps
                                                                    (fun
                                                                    t0 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t0)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    UnderLets.Base
                                                                    (-
                                                                    (x * x' v))%expr
                                                                    | None =>
                                                                    default
                                                                    end)
                                                               | (s0 -> d0)%ptype =>
                                                                   fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                                   => default
                                                               end
                                                                 (Compile.reflect
                                                                    x1)
                                                           | None => default
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         ($_)%expr _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.Abs _ _ _ _ _
                                                          _) _ | @expr.App _
                                                         _ _ s _
                                                         (_ @ _)%expr_pat _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.LetIn _ _ _ _
                                                          _ _ _) _ => default
                                                       | _ => default0 tt
                                                       end in
                                                       match x with
                                                       | @expr.App _ _ _ s _
                                                         #(idc)%expr_pat
                                                         x1 =>
                                                           match
                                                             match idc with
                                                             | ident.Z_opp =>
                                                                 Some tt
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some _ =>
                                                               match
                                                                 s as t2
                                                                 return
                                                                   (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                               with
                                                               | type.base
                                                                 t2 =>
                                                                   fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                   base.try_make_transport_cps
                                                                    (fun
                                                                    t0 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t0)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    UnderLets.Base
                                                                    (-
                                                                    (x' v *
                                                                    x0))%expr
                                                                    | None =>
                                                                    default
                                                                    end)
                                                               | (s0 -> d0)%ptype =>
                                                                   fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                                   => default
                                                               end
                                                                 (Compile.reflect
                                                                    x1)
                                                           | None => default
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         ($_)%expr _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.Abs _ _ _ _ _
                                                          _) _ | @expr.App _
                                                         _ _ s _
                                                         (_ @ _)%expr_pat _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.LetIn _ _ _ _
                                                          _ _ _) _ => default
                                                       | _ => default0 tt
                                                       end in
                                                       match x0 with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if args <? 0
                                                               then
                                                                UnderLets.Base
                                                                  (-
                                                                   (x *
                                                                    ##
                                                                    ((- args)%Z)))%expr
                                                               else default
                                                           | None =>
                                                               default0 tt
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         #(idc)%expr_pat
                                                         x1 =>
                                                           match
                                                             match idc with
                                                             | ident.Z_opp =>
                                                                 Some tt
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some _ =>
                                                               match x with
                                                               | @expr.App _
                                                                 _ _ s0 _
                                                                 #(idc0)%expr_pat
                                                                 x2 =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | ident.Z_opp =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    _ =>
                                                                    match
                                                                    s0 as t2
                                                                    return
                                                                    (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t2 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t1 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t1)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    match
                                                                    s as t3
                                                                    return
                                                                    (Compile.value'
                                                                    false t3 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t3 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t1 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t1)) t3
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    UnderLets.Base
                                                                    (x' v *
                                                                    x'0 v0)%expr
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    default
                                                                   end
                                                               | @expr.App _
                                                                 _ _ s0 _
                                                                 ($_)%expr
                                                                 _ |
                                                                 @expr.App _
                                                                 _ _ s0 _
                                                                 (@expr.Abs _
                                                                  _ _ _ _ _)
                                                                 _ |
                                                                 @expr.App _
                                                                 _ _ s0 _
                                                                 (_ @ _)%expr_pat
                                                                 _ |
                                                                 @expr.App _
                                                                 _ _ s0 _
                                                                 (@expr.LetIn
                                                                  _ _ _ _ _ _
                                                                  _) _ =>
                                                                   default
                                                               | _ => default
                                                               end
                                                           | None => default
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         ($_)%expr _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.Abs _ _ _ _ _
                                                          _) _ | @expr.App _
                                                         _ _ s _
                                                         (_ @ _)%expr_pat _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.LetIn _ _ _ _
                                                          _ _ _) _ => default
                                                       | _ => default0 tt
                                                       end in
                                                       match x with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if args <? 0
                                                               then
                                                                UnderLets.Base
                                                                  (-
                                                                   (##
                                                                    ((- args)%Z) *
                                                                    x0))%expr
                                                               else default
                                                           | None =>
                                                               default0 tt
                                                           end
                                                       | _ => default0 tt
                                                       end in
                                                       match x0 with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if args =? -1
                                                               then
                                                                UnderLets.Base
                                                                  (- x)%expr
                                                               else default
                                                           | None =>
                                                               default0 tt
                                                           end
                                                       | _ => default0 tt
                                                       end in
                                                       match x with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if args =? -1
                                                               then
                                                                UnderLets.Base
                                                                  (- x0)%expr
                                                               else default
                                                           | None =>
                                                               default0 tt
                                                           end
                                                       | _ => default0 tt
                                                       end in
                                                       match x0 with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if args =? 1
                                                               then
                                                                UnderLets.Base
                                                                  x
                                                               else
                                                                match x with
                                                                | @expr.App _
                                                                  _ _ s _
                                                                  #(idc0)%expr_pat
                                                                  x1 =>
                                                                    match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | ident.Z_opp =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    _ =>
                                                                    match
                                                                    s as t2
                                                                    return
                                                                    (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t2 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t1 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t1)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    if
                                                                    args =?
                                                                    -1
                                                                    then
                                                                    UnderLets.Base
                                                                    (x' v)
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s0 ->
                                                                    d0)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                    | None =>
                                                                    default
                                                                    end
                                                                | @expr.App _
                                                                  _ _ s _
                                                                  ($_)%expr
                                                                  _ |
                                                                  @expr.App _
                                                                  _ _ s _
                                                                  (@expr.Abs
                                                                   _ _ _ _ _
                                                                   _) _ |
                                                                  @expr.App _
                                                                  _ _ s _
                                                                  (_ @ _)%expr_pat
                                                                  _ |
                                                                  @expr.App _
                                                                  _ _ s _
                                                                  (@expr.LetIn
                                                                   _ _ _ _ _
                                                                   _ _) _ =>
                                                                    default
                                                                | _ =>
                                                                    default
                                                                end
                                                           | None =>
                                                               default0 tt
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         #(idc)%expr_pat
                                                         x1 =>
                                                           match
                                                             match idc with
                                                             | ident.Z_opp =>
                                                                 Some tt
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some _ =>
                                                               match x with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    match
                                                                    s as t2
                                                                    return
                                                                    (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t2 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t1 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t1)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    if
                                                                    args0 =?
                                                                    -1
                                                                    then
                                                                    UnderLets.Base
                                                                    (x' v)
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s0 ->
                                                                    d0)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                   | None =>
                                                                    default
                                                                   end
                                                               | _ => default
                                                               end
                                                           | None => default
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         ($_)%expr _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.Abs _ _ _ _ _
                                                          _) _ | @expr.App _
                                                         _ _ s _
                                                         (_ @ _)%expr_pat _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.LetIn _ _ _ _
                                                          _ _ _) _ => default
                                                       | _ => default0 tt
                                                       end in
                                      match x with
                                      | #(idc)%expr_pat =>
                                          match
                                            match idc with
                                            | @ident.Literal t0 v =>
                                                match
                                                  t0 as t1
                                                  return
                                                    (base.base_interp t1 ->
                                                     option Z)
                                                with
                                                | base.type.unit =>
                                                    fun _ : unit => None
                                                | base.type.Z =>
                                                    fun v0 : Z => Some v0
                                                | base.type.bool =>
                                                    fun _ : bool => None
                                                | base.type.nat =>
                                                    fun _ : nat => None
                                                end v
                                            | _ => None
                                            end
                                          with
                                          | Some args =>
                                              if args =? 1
                                              then UnderLets.Base x0
                                              else default
                                          | None => default0 tt
                                          end
                                      | _ => default0 tt
                                      end in
                     match x0 with
                     | #(idc)%expr_pat =>
                         match
                           match idc with
                           | @ident.Literal t0 v =>
                               match
                                 t0 as t1
                                 return (base.base_interp t1 -> option Z)
                               with
                               | base.type.unit => fun _ : unit => None
                               | base.type.Z => fun v0 : Z => Some v0
                               | base.type.bool => fun _ : bool => None
                               | base.type.nat => fun _ : nat => None
                               end v
                           | _ => None
                           end
                         with
                         | Some args =>
                             if args =? 0
                             then UnderLets.Base ##(0)%expr
                             else default
                         | None => default0 tt
                         end
                     | _ => default0 tt
                     end in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 0 then UnderLets.Base ##(0)%expr else default
        | None => default0 tt
        end
    | _ => default0 tt
    end
| ident.Z_pow =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_pow)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_sub =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x - x0)%expr in
    llet default0 := fun 'tt =>
                     llet default0 := fun 'tt =>
                                      llet default0 := fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       match x0 with
                                                       | @expr.App _ _ _ s _
                                                         #(idc)%expr_pat
                                                         x1 =>
                                                           match
                                                             match idc with
                                                             | ident.Z_opp =>
                                                                 Some tt
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some _ =>
                                                               match
                                                                 s as t2
                                                                 return
                                                                   (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                               with
                                                               | type.base
                                                                 t2 =>
                                                                   fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                   base.try_make_transport_cps
                                                                    (fun
                                                                    t0 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t0)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    UnderLets.Base
                                                                    (x + x' v)%expr
                                                                    | None =>
                                                                    default
                                                                    end)
                                                               | (s0 -> d0)%ptype =>
                                                                   fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                                   => default
                                                               end
                                                                 (Compile.reflect
                                                                    x1)
                                                           | None => default
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         ($_)%expr _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.Abs _ _ _ _ _
                                                          _) _ | @expr.App _
                                                         _ _ s _
                                                         (_ @ _)%expr_pat _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.LetIn _ _ _ _
                                                          _ _ _) _ => default
                                                       | _ => default
                                                       end in
                                                       match x with
                                                       | @expr.App _ _ _ s _
                                                         #(idc)%expr_pat
                                                         x1 =>
                                                           match
                                                             match idc with
                                                             | ident.Z_opp =>
                                                                 Some tt
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some _ =>
                                                               match
                                                                 s as t2
                                                                 return
                                                                   (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                               with
                                                               | type.base
                                                                 t2 =>
                                                                   fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                   base.try_make_transport_cps
                                                                    (fun
                                                                    t0 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t0)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    UnderLets.Base
                                                                    (-
                                                                    (x' v +
                                                                    x0))%expr
                                                                    | None =>
                                                                    default
                                                                    end)
                                                               | (s0 -> d0)%ptype =>
                                                                   fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                                   => default
                                                               end
                                                                 (Compile.reflect
                                                                    x1)
                                                           | None => default
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         ($_)%expr _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.Abs _ _ _ _ _
                                                          _) _ | @expr.App _
                                                         _ _ s _
                                                         (_ @ _)%expr_pat _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.LetIn _ _ _ _
                                                          _ _ _) _ => default
                                                       | _ => default0 tt
                                                       end in
                                                       match x0 with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if args <? 0
                                                               then
                                                                UnderLets.Base
                                                                  (x +
                                                                   ##
                                                                   ((- args)%Z))%expr
                                                               else default
                                                           | None =>
                                                               default0 tt
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         #(idc)%expr_pat
                                                         x1 =>
                                                           match
                                                             match idc with
                                                             | ident.Z_opp =>
                                                                 Some tt
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some _ =>
                                                               match x with
                                                               | @expr.App _
                                                                 _ _ s0 _
                                                                 #(idc0)%expr_pat
                                                                 x2 =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | ident.Z_opp =>
                                                                    Some tt
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    _ =>
                                                                    match
                                                                    s0 as t2
                                                                    return
                                                                    (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t2 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t1 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t1)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    match
                                                                    s as t3
                                                                    return
                                                                    (Compile.value'
                                                                    false t3 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    with
                                                                    | type.base
                                                                    t3 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t1 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t1)) t3
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    UnderLets.Base
                                                                    (x'0 v0 -
                                                                    x' v)%expr
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x1)
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s1 ->
                                                                    d1)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s1 ->
                                                                    Compile.value'
                                                                    true d1
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x2)
                                                                   | None =>
                                                                    default
                                                                   end
                                                               | @expr.App _
                                                                 _ _ s0 _
                                                                 ($_)%expr
                                                                 _ |
                                                                 @expr.App _
                                                                 _ _ s0 _
                                                                 (@expr.Abs _
                                                                  _ _ _ _ _)
                                                                 _ |
                                                                 @expr.App _
                                                                 _ _ s0 _
                                                                 (_ @ _)%expr_pat
                                                                 _ |
                                                                 @expr.App _
                                                                 _ _ s0 _
                                                                 (@expr.LetIn
                                                                  _ _ _ _ _ _
                                                                  _) _ =>
                                                                   default
                                                               | _ => default
                                                               end
                                                           | None => default
                                                           end
                                                       | @expr.App _ _ _ s _
                                                         ($_)%expr _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.Abs _ _ _ _ _
                                                          _) _ | @expr.App _
                                                         _ _ s _
                                                         (_ @ _)%expr_pat _ |
                                                         @expr.App _ _ _ s _
                                                         (@expr.LetIn _ _ _ _
                                                          _ _ _) _ => default
                                                       | _ => default0 tt
                                                       end in
                                      match x with
                                      | #(idc)%expr_pat =>
                                          match
                                            match idc with
                                            | @ident.Literal t0 v =>
                                                match
                                                  t0 as t1
                                                  return
                                                    (base.base_interp t1 ->
                                                     option Z)
                                                with
                                                | base.type.unit =>
                                                    fun _ : unit => None
                                                | base.type.Z =>
                                                    fun v0 : Z => Some v0
                                                | base.type.bool =>
                                                    fun _ : bool => None
                                                | base.type.nat =>
                                                    fun _ : nat => None
                                                end v
                                            | _ => None
                                            end
                                          with
                                          | Some args =>
                                              if args <? 0
                                              then
                                               UnderLets.Base
                                                 (- (##((- args)%Z) + x0))%expr
                                              else default
                                          | None => default0 tt
                                          end
                                      | @expr.App _ _ _ s _ #(idc)%expr_pat
                                        x1 =>
                                          match
                                            match idc with
                                            | ident.Z_opp => Some tt
                                            | _ => None
                                            end
                                          with
                                          | Some _ =>
                                              match x0 with
                                              | #(idc0)%expr_pat =>
                                                  match
                                                    match idc0 with
                                                    | @ident.Literal t1 v =>
                                                        match
                                                          t1 as t2
                                                          return
                                                            (base.base_interp
                                                               t2 -> 
                                                             option Z)
                                                        with
                                                        | base.type.unit =>
                                                            fun _ : unit =>
                                                            None
                                                        | base.type.Z =>
                                                            fun v0 : Z =>
                                                            Some v0
                                                        | base.type.bool =>
                                                            fun _ : bool =>
                                                            None
                                                        | base.type.nat =>
                                                            fun _ : nat =>
                                                            None
                                                        end v
                                                    | _ => None
                                                    end
                                                  with
                                                  | Some args0 =>
                                                      match
                                                        s as t2
                                                        return
                                                          (Compile.value'
                                                             false t2 ->
                                                           UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   base.type.Z)))
                                                      with
                                                      | type.base t2 =>
                                                          fun
                                                            v : defaults.expr
                                                                  (type.base
                                                                    t2) =>
                                                          base.try_make_transport_cps
                                                            (fun
                                                               t1 : base.type
                                                             =>
                                                             defaults.expr
                                                               (type.base t1))
                                                            t2 base.type.Z
                                                            (UnderLets.UnderLets
                                                               base.type
                                                               ident var
                                                               (defaults.expr
                                                                  (type.base
                                                                    base.type.Z)))
                                                            (fun
                                                               a : option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                             =>
                                                             match a with
                                                             | Some x' =>
                                                                 if
                                                                  args0 >? 0
                                                                 then
                                                                  UnderLets.Base
                                                                    (-
                                                                    (x' v +
                                                                    ##
                                                                    ((- args0)%Z)))%expr
                                                                 else
                                                                  match
                                                                    s as t3
                                                                    return
                                                                    (Compile.value'
                                                                    false t3 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                  with
                                                                  | type.base
                                                                    t3 =>
                                                                    fun
                                                                    v0 : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t3) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t1 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t1)) t3
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    base.type.Z)))
                                                                    (fun
                                                                    a0 : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a0
                                                                    with
                                                                    | Some
                                                                    x'0 =>
                                                                    if
                                                                    args0 <?
                                                                    0
                                                                    then
                                                                    UnderLets.Base
                                                                    (##
                                                                    ((- args0)%Z) -
                                                                    x'0 v0)%expr
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                  | (s0 -> d0)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                                    =>
                                                                    default
                                                                  end
                                                                    (Compile.reflect
                                                                    x1)
                                                             | None =>
                                                                 default
                                                             end)
                                                      | (s0 -> d0)%ptype =>
                                                          fun
                                                            _ : Compile.value'
                                                                  false s0 ->
                                                                Compile.value'
                                                                  true d0 =>
                                                          default
                                                      end
                                                        (Compile.reflect x1)
                                                  | None => default
                                                  end
                                              | _ => default
                                              end
                                          | None => default
                                          end
                                      | @expr.App _ _ _ s _ ($_)%expr _ |
                                        @expr.App _ _ _ s _
                                        (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                                        _ _ _ s _ (_ @ _)%expr_pat _ |
                                        @expr.App _ _ _ s _
                                        (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                          default
                                      | _ => default0 tt
                                      end in
                     match x0 with
                     | #(idc)%expr_pat =>
                         match
                           match idc with
                           | @ident.Literal t0 v =>
                               match
                                 t0 as t1
                                 return (base.base_interp t1 -> option Z)
                               with
                               | base.type.unit => fun _ : unit => None
                               | base.type.Z => fun v0 : Z => Some v0
                               | base.type.bool => fun _ : bool => None
                               | base.type.nat => fun _ : nat => None
                               end v
                           | _ => None
                           end
                         with
                         | Some args =>
                             if args =? 0 then UnderLets.Base x else default
                         | None => default0 tt
                         end
                     | @expr.App _ _ _ s _ #(idc)%expr_pat x1 =>
                         match
                           match idc with
                           | ident.Z_opp => Some tt
                           | _ => None
                           end
                         with
                         | Some _ =>
                             match x with
                             | #(idc0)%expr_pat =>
                                 match
                                   match idc0 with
                                   | @ident.Literal t1 v =>
                                       match
                                         t1 as t2
                                         return
                                           (base.base_interp t2 -> option Z)
                                       with
                                       | base.type.unit =>
                                           fun _ : unit => None
                                       | base.type.Z => fun v0 : Z => Some v0
                                       | base.type.bool =>
                                           fun _ : bool => None
                                       | base.type.nat => fun _ : nat => None
                                       end v
                                   | _ => None
                                   end
                                 with
                                 | Some args0 =>
                                     match
                                       s as t2
                                       return
                                         (Compile.value' false t2 ->
                                          UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base base.type.Z)))
                                     with
                                     | type.base t2 =>
                                         fun v : defaults.expr (type.base t2)
                                         =>
                                         base.try_make_transport_cps
                                           (fun t1 : base.type =>
                                            defaults.expr (type.base t1)) t2
                                           base.type.Z
                                           (UnderLets.UnderLets base.type
                                              ident var
                                              (defaults.expr
                                                 (type.base base.type.Z)))
                                           (fun
                                              a : option
                                                    (defaults.expr
                                                       (type.base t2) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                            =>
                                            match a with
                                            | Some x' =>
                                                if args0 >? 0
                                                then
                                                 UnderLets.Base
                                                   (##(args0) + x' v)%expr
                                                else
                                                 match
                                                   s as t3
                                                   return
                                                     (Compile.value' false t3 ->
                                                      UnderLets.UnderLets
                                                        base.type ident var
                                                        (defaults.expr
                                                           (type.base
                                                              base.type.Z)))
                                                 with
                                                 | type.base t3 =>
                                                     fun
                                                       v0 : defaults.expr
                                                              (type.base t3)
                                                     =>
                                                     base.try_make_transport_cps
                                                       (fun t1 : base.type =>
                                                        defaults.expr
                                                          (type.base t1)) t3
                                                       base.type.Z
                                                       (UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                base.type.Z)))
                                                       (fun
                                                          a0 : option
                                                                 (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                  defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                        =>
                                                        match a0 with
                                                        | Some x'0 =>
                                                            if args0 <? 0
                                                            then
                                                             UnderLets.Base
                                                               (x'0 v0 -
                                                                ##((- args0)%Z))%expr
                                                            else default
                                                        | None => default
                                                        end)
                                                 | (s0 -> d0)%ptype =>
                                                     fun
                                                       _ : Compile.value'
                                                             false s0 ->
                                                           Compile.value'
                                                             true d0 =>
                                                     default
                                                 end (Compile.reflect x1)
                                            | None => default
                                            end)
                                     | (s0 -> d0)%ptype =>
                                         fun
                                           _ : Compile.value' false s0 ->
                                               Compile.value' true d0 =>
                                         default
                                     end (Compile.reflect x1)
                                 | None => default
                                 end
                             | _ => default
                             end
                         | None => default
                         end
                     | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
                       (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
                       (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                       (@expr.LetIn _ _ _ _ _ _ _) _ => default
                     | _ => default0 tt
                     end in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            llet default1 := fun 'tt =>
                             if args =? 0
                             then UnderLets.Base (- x0)%expr
                             else default in
            match x0 with
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x1 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr (type.base base.type.Z)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr (type.base base.type.Z)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if args =? 0
                               then UnderLets.Base (x' v)
                               else default
                           | None => default
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 => default
                    end (Compile.reflect x1)
                | None => default
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ => default
            | _ => default1 tt
            end
        | None => default0 tt
        end
    | _ => default0 tt
    end
| ident.Z_opp =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (- x)%expr in
    llet default0 := fun 'tt =>
                     if negb (SubstVarLike.is_var_fst_snd_pair_opp x)
                     then
                      UnderLets.UnderLet x
                        (fun v : var (type.base base.type.Z) =>
                         UnderLets.Base (- $v)%expr)
                     else default in
    match x with
    | @expr.App _ _ _ s _ #(idc)%expr_pat x0 =>
        match match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end with
        | Some _ =>
            match
              s as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (defaults.expr (type.base base.type.Z)))
            with
            | type.base t2 =>
                fun v : defaults.expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => defaults.expr (type.base t0)) t2
                  base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr (type.base base.type.Z)))
                  (fun
                     a : option
                           (defaults.expr (type.base t2) ->
                            defaults.expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' => UnderLets.Base (x' v)
                   | None => default
                   end)
            | (s0 -> d0)%ptype =>
                fun _ : Compile.value' false s0 -> Compile.value' true d0 =>
                default
            end (Compile.reflect x0)
        | None => default
        end
    | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
      @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => default
    | _ => default0 tt
    end
| ident.Z_div =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x / x0)%expr in
    match x0 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 1
            then UnderLets.Base x
            else
             if args =? 2 ^ Z.log2 args
             then UnderLets.Base (x >> ##(Z.log2 args))%expr
             else default
        | None => default
        end
    | _ => default
    end
| ident.Z_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x mod x0)%expr in
    match x0 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 1
            then UnderLets.Base ##(0)%expr
            else
             if args =? 2 ^ Z.log2 args
             then UnderLets.Base (x &' ##((args - 1)%Z))%expr
             else default
        | None => default
        end
    | _ => default
    end
| ident.Z_log2 =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_log2)%expr @ x)%expr_pat in
    default
| ident.Z_log2_up =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_log2_up)%expr @ x)%expr_pat in
    default
| ident.Z_eqb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_eqb)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_leb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_leb)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_geb =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_geb)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_of_nat =>
    fun x : defaults.expr (type.base base.type.nat) =>
    llet default := UnderLets.Base (#(ident.Z_of_nat)%expr @ x)%expr_pat in
    default
| ident.Z_to_nat =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_to_nat)%expr @ x)%expr_pat in
    default
| ident.Z_shiftr =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x >> x0)%expr in
    default
| ident.Z_shiftl =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x << x0)%expr in
    default
| ident.Z_land =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x &' x0)%expr in
    llet default0 := fun 'tt =>
                     match x with
                     | #(idc)%expr_pat =>
                         match
                           match idc with
                           | @ident.Literal t0 v =>
                               match
                                 t0 as t1
                                 return (base.base_interp t1 -> option Z)
                               with
                               | base.type.unit => fun _ : unit => None
                               | base.type.Z => fun v0 : Z => Some v0
                               | base.type.bool => fun _ : bool => None
                               | base.type.nat => fun _ : nat => None
                               end v
                           | _ => None
                           end
                         with
                         | Some args =>
                             if args =? 0
                             then UnderLets.Base ##(0)%expr
                             else default
                         | None => default
                         end
                     | _ => default
                     end in
    match x0 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 0 then UnderLets.Base ##(0)%expr else default
        | None => default0 tt
        end
    | _ => default0 tt
    end
| ident.Z_lor =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (x || x0)%expr in
    default
| ident.Z_bneg =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_bneg)%expr @ x)%expr_pat in
    default
| ident.Z_lnot_modulo =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_lnot_modulo)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_mul_split =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat in
    llet default0 := fun 'tt =>
                     UnderLets.UnderLet
                       (#(ident.Z_mul_split)%expr @ x @ x0 @ x1)%expr_pat
                       (fun
                          v : var
                                (type.base (base.type.Z * base.type.Z)%etype)
                        =>
                        UnderLets.Base
                          (#(ident.fst)%expr @ ($v)%expr,
                          #(ident.snd)%expr @ ($v)%expr)%expr_pat) in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some _ =>
            llet default1 := fun 'tt =>
                             llet default1 := fun 'tt =>
                                              llet default1 := fun 'tt =>
                                                               llet default1 := 
                                                               fun 'tt =>
                                                               llet default1 := 
                                                               fun 'tt =>
                                                               match x1 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    if
                                                                    args0 =?
                                                                    -1
                                                                    then
                                                                    UnderLets.Base
                                                                    (
                                                                    (- x0)%expr,
                                                                    ##
                                                                    (0)%expr)%expr_pat
                                                                    else
                                                                    default
                                                                   | None =>
                                                                    default
                                                                   end
                                                               | _ => default
                                                               end in
                                                               match x0 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    if
                                                                    args0 =?
                                                                    -1
                                                                    then
                                                                    UnderLets.Base
                                                                    (
                                                                    (- x1)%expr,
                                                                    ##
                                                                    (0)%expr)%expr_pat
                                                                    else
                                                                    default
                                                                   | None =>
                                                                    default1
                                                                    tt
                                                                   end
                                                               | _ =>
                                                                   default1
                                                                    tt
                                                               end in
                                                               match x1 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    if
                                                                    args0 =?
                                                                    1
                                                                    then
                                                                    UnderLets.Base
                                                                    (x0,
                                                                    ##
                                                                    (0)%expr)%expr_pat
                                                                    else
                                                                    default
                                                                   | None =>
                                                                    default1
                                                                    tt
                                                                   end
                                                               | _ =>
                                                                   default1
                                                                    tt
                                                               end in
                                              match x0 with
                                              | #(idc0)%expr_pat =>
                                                  match
                                                    match idc0 with
                                                    | @ident.Literal t1 v =>
                                                        match
                                                          t1 as t2
                                                          return
                                                            (base.base_interp
                                                               t2 -> 
                                                             option Z)
                                                        with
                                                        | base.type.unit =>
                                                            fun _ : unit =>
                                                            None
                                                        | base.type.Z =>
                                                            fun v0 : Z =>
                                                            Some v0
                                                        | base.type.bool =>
                                                            fun _ : bool =>
                                                            None
                                                        | base.type.nat =>
                                                            fun _ : nat =>
                                                            None
                                                        end v
                                                    | _ => None
                                                    end
                                                  with
                                                  | Some args0 =>
                                                      if args0 =? 1
                                                      then
                                                       UnderLets.Base
                                                         (x1, ##(0)%expr)%expr_pat
                                                      else default
                                                  | None => default1 tt
                                                  end
                                              | _ => default1 tt
                                              end in
                             match x1 with
                             | #(idc0)%expr_pat =>
                                 match
                                   match idc0 with
                                   | @ident.Literal t1 v =>
                                       match
                                         t1 as t2
                                         return
                                           (base.base_interp t2 -> option Z)
                                       with
                                       | base.type.unit =>
                                           fun _ : unit => None
                                       | base.type.Z => fun v0 : Z => Some v0
                                       | base.type.bool =>
                                           fun _ : bool => None
                                       | base.type.nat => fun _ : nat => None
                                       end v
                                   | _ => None
                                   end
                                 with
                                 | Some args0 =>
                                     if args0 =? 0
                                     then
                                      UnderLets.Base
                                        (##(0)%expr, ##(0)%expr)%expr_pat
                                     else default
                                 | None => default1 tt
                                 end
                             | _ => default1 tt
                             end in
            match x0 with
            | #(idc0)%expr_pat =>
                match
                  match idc0 with
                  | @ident.Literal t1 v =>
                      match
                        t1 as t2 return (base.base_interp t2 -> option Z)
                      with
                      | base.type.unit => fun _ : unit => None
                      | base.type.Z => fun v0 : Z => Some v0
                      | base.type.bool => fun _ : bool => None
                      | base.type.nat => fun _ : nat => None
                      end v
                  | _ => None
                  end
                with
                | Some args0 =>
                    if args0 =? 0
                    then UnderLets.Base (##(0)%expr, ##(0)%expr)%expr_pat
                    else default
                | None => default1 tt
                end
            | _ => default1 tt
            end
        | None => default0 tt
        end
    | _ => default0 tt
    end
| ident.Z_add_get_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_add_get_carry)%expr @ x @ x0 @ x1)%expr_pat in
    llet default0 := fun 'tt =>
                     llet default0 := fun 'tt =>
                                      llet default0 := fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       llet default0 := 
                                                       fun 'tt =>
                                                       UnderLets.UnderLet
                                                         (#(ident.Z_add_get_carry)%expr @
                                                          x @ x0 @ x1)%expr_pat
                                                         (fun
                                                            v : var
                                                                  (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                          =>
                                                          UnderLets.Base
                                                            (#(ident.fst)%expr @
                                                             ($v)%expr,
                                                            #(ident.snd)%expr @
                                                            ($v)%expr)%expr_pat) in
                                                       match x1 with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if args =? 0
                                                               then
                                                                UnderLets.Base
                                                                  (x0,
                                                                  ##(0)%expr)%expr_pat
                                                               else default
                                                           | None =>
                                                               default0 tt
                                                           end
                                                       | _ => default0 tt
                                                       end in
                                                       match x0 with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if args =? 0
                                                               then
                                                                UnderLets.Base
                                                                  (x1,
                                                                  ##(0)%expr)%expr_pat
                                                               else default
                                                           | None =>
                                                               default0 tt
                                                           end
                                                       | _ => default0 tt
                                                       end in
                                                       match x1 with
                                                       | #(idc)%expr_pat =>
                                                           match
                                                             match idc with
                                                             | @ident.Literal
                                                               t0 v =>
                                                                 match
                                                                   t0 as t1
                                                                   return
                                                                    (base.base_interp
                                                                    t1 ->
                                                                    option Z)
                                                                 with
                                                                 | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                 | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                 | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                 | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                 end v
                                                             | _ => None
                                                             end
                                                           with
                                                           | Some args =>
                                                               if args <? 0
                                                               then
                                                                UnderLets.UnderLet
                                                                  (#(ident.Z_sub_get_borrow)%expr @
                                                                   x @ x0 @
                                                                   ##
                                                                   ((- args)%Z)%expr)%expr_pat
                                                                  (fun
                                                                    v : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                   =>
                                                                   UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v)%expr,
                                                                    (-
                                                                    (#
                                                                    (ident.snd)%expr @
                                                                    $v)%expr_pat)%expr)%expr_pat)
                                                               else default
                                                           | None =>
                                                               default0 tt
                                                           end
                                                       | _ => default0 tt
                                                       end in
                                      match x0 with
                                      | #(idc)%expr_pat =>
                                          match
                                            match idc with
                                            | @ident.Literal t0 v =>
                                                match
                                                  t0 as t1
                                                  return
                                                    (base.base_interp t1 ->
                                                     option Z)
                                                with
                                                | base.type.unit =>
                                                    fun _ : unit => None
                                                | base.type.Z =>
                                                    fun v0 : Z => Some v0
                                                | base.type.bool =>
                                                    fun _ : bool => None
                                                | base.type.nat =>
                                                    fun _ : nat => None
                                                end v
                                            | _ => None
                                            end
                                          with
                                          | Some args =>
                                              if args <? 0
                                              then
                                               UnderLets.UnderLet
                                                 (#(ident.Z_sub_get_borrow)%expr @
                                                  x @ x1 @
                                                  ##((- args)%Z)%expr)%expr_pat
                                                 (fun
                                                    v : var
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)
                                                  =>
                                                  UnderLets.Base
                                                    (#(ident.fst)%expr @
                                                     ($v)%expr,
                                                    (-
                                                     (#(ident.snd)%expr @ $v)%expr_pat)%expr)%expr_pat)
                                              else default
                                          | None => default0 tt
                                          end
                                      | _ => default0 tt
                                      end in
                     match x1 with
                     | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
                         match
                           match idc with
                           | ident.Z_opp => Some tt
                           | _ => None
                           end
                         with
                         | Some _ =>
                             match
                               s as t2
                               return
                                 (Compile.value' false t2 ->
                                  UnderLets.UnderLets base.type ident var
                                    (defaults.expr
                                       (type.base
                                          (base.type.Z * base.type.Z)%etype)))
                             with
                             | type.base t2 =>
                                 fun v : defaults.expr (type.base t2) =>
                                 base.try_make_transport_cps
                                   (fun t0 : base.type =>
                                    defaults.expr (type.base t0)) t2
                                   base.type.Z
                                   (UnderLets.UnderLets base.type ident var
                                      (defaults.expr
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)))
                                   (fun
                                      a : option
                                            (defaults.expr (type.base t2) ->
                                             defaults.expr
                                               (type.base base.type.Z)) =>
                                    match a with
                                    | Some x' =>
                                        UnderLets.UnderLet
                                          (#(ident.Z_sub_get_borrow)%expr @ x @
                                           x0 @ x' v)%expr_pat
                                          (fun
                                             v0 : var
                                                    (type.base
                                                       (base.type.Z *
                                                        base.type.Z)%etype)
                                           =>
                                           UnderLets.Base
                                             (#(ident.fst)%expr @ ($v0)%expr,
                                             (-
                                              (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                                    | None => default
                                    end)
                             | (s0 -> d0)%ptype =>
                                 fun
                                   _ : Compile.value' false s0 ->
                                       Compile.value' true d0 => default
                             end (Compile.reflect x2)
                         | None => default
                         end
                     | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
                       (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
                       (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
                       (@expr.LetIn _ _ _ _ _ _ _) _ => default
                     | _ => default0 tt
                     end in
    match x0 with
    | @expr.App _ _ _ s _ #(idc)%expr_pat x2 =>
        match match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end with
        | Some _ =>
            match
              s as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (defaults.expr
                      (type.base (base.type.Z * base.type.Z)%etype)))
            with
            | type.base t2 =>
                fun v : defaults.expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => defaults.expr (type.base t0)) t2
                  base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr
                        (type.base (base.type.Z * base.type.Z)%etype)))
                  (fun
                     a : option
                           (defaults.expr (type.base t2) ->
                            defaults.expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' =>
                       UnderLets.UnderLet
                         (#(ident.Z_sub_get_borrow)%expr @ x @ x1 @ x' v)%expr_pat
                         (fun
                            v0 : var
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype) =>
                          UnderLets.Base
                            (#(ident.fst)%expr @ ($v0)%expr,
                            (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                   | None => default
                   end)
            | (s0 -> d0)%ptype =>
                fun _ : Compile.value' false s0 -> Compile.value' true d0 =>
                default
            end (Compile.reflect x2)
        | None => default
        end
    | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
      @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => default
    | _ => default0 tt
    end
| ident.Z_add_with_carry =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat in
    llet default0 := fun 'tt =>
                     UnderLets.UnderLet
                       (#(ident.Z_add_with_carry)%expr @ x @ x0 @ x1)%expr_pat
                       (fun v : var (type.base base.type.Z) =>
                        UnderLets.Base ($v)%expr) in
    match x with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            if args =? 0 then UnderLets.Base (x0 + x1)%expr else default
        | None => default0 tt
        end
    | _ => default0 tt
    end
| ident.Z_add_with_get_carry =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_add_with_get_carry)%expr @ x @ x0 @ x1 @ x2)%expr_pat in
    llet default0 := fun 'tt =>
                     llet default0 := fun 'tt =>
                                      UnderLets.UnderLet
                                        (#(ident.Z_add_with_get_carry)%expr @
                                         x @ x0 @ x1 @ x2)%expr_pat
                                        (fun
                                           v : var
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype) =>
                                         UnderLets.Base
                                           (#(ident.fst)%expr @ ($v)%expr,
                                           #(ident.snd)%expr @ ($v)%expr)%expr_pat) in
                     match x1 with
                     | #(idc)%expr_pat =>
                         match
                           match idc with
                           | @ident.Literal t0 v =>
                               match
                                 t0 as t1
                                 return (base.base_interp t1 -> option Z)
                               with
                               | base.type.unit => fun _ : unit => None
                               | base.type.Z => fun v0 : Z => Some v0
                               | base.type.bool => fun _ : bool => None
                               | base.type.nat => fun _ : nat => None
                               end v
                           | _ => None
                           end
                         with
                         | Some args =>
                             match x2 with
                             | #(idc0)%expr_pat =>
                                 match
                                   match idc0 with
                                   | @ident.Literal t1 v =>
                                       match
                                         t1 as t2
                                         return
                                           (base.base_interp t2 -> option Z)
                                       with
                                       | base.type.unit =>
                                           fun _ : unit => None
                                       | base.type.Z => fun v0 : Z => Some v0
                                       | base.type.bool =>
                                           fun _ : bool => None
                                       | base.type.nat => fun _ : nat => None
                                       end v
                                   | _ => None
                                   end
                                 with
                                 | Some args0 =>
                                     if (args =? 0) && (args0 =? 0)
                                     then
                                      UnderLets.UnderLet
                                        (#(ident.Z_add_with_get_carry)%expr @
                                         x @ x0 @ ##(args)%expr @
                                         ##(args0)%expr)%expr_pat
                                        (fun
                                           v : var
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype) =>
                                         UnderLets.Base
                                           (#(ident.fst)%expr @ ($v)%expr,
                                           ##(0)%expr)%expr_pat)
                                     else default
                                 | None => default
                                 end
                             | _ => default
                             end
                         | None => default0 tt
                         end
                     | _ => default0 tt
                     end in
    match x0 with
    | #(idc)%expr_pat =>
        match
          match idc with
          | @ident.Literal t0 v =>
              match t0 as t1 return (base.base_interp t1 -> option Z) with
              | base.type.unit => fun _ : unit => None
              | base.type.Z => fun v0 : Z => Some v0
              | base.type.bool => fun _ : bool => None
              | base.type.nat => fun _ : nat => None
              end v
          | _ => None
          end
        with
        | Some args =>
            llet default1 := fun 'tt =>
                             llet default1 := fun 'tt =>
                                              llet default1 := fun 'tt =>
                                                               llet default1 := 
                                                               fun 'tt =>
                                                               llet default1 := 
                                                               fun 'tt =>
                                                               if args =? 0
                                                               then
                                                                UnderLets.UnderLet
                                                                  (#(ident.Z_add_get_carry)%expr @
                                                                   x @ x1 @
                                                                   x2)%expr_pat
                                                                  (fun
                                                                    v : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                   =>
                                                                   UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v)%expr,
                                                                    #
                                                                    (ident.snd)%expr @
                                                                    ($v)%expr)%expr_pat)
                                                               else default in
                                                               match x with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    _ =>
                                                                    llet default2 := 
                                                                    fun 'tt
                                                                    =>
                                                                    match
                                                                    x2
                                                                    with
                                                                    | #
                                                                    (idc1)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | @ident.Literal
                                                                    t2 v =>
                                                                    match
                                                                    t2 as t3
                                                                    return
                                                                    (base.base_interp
                                                                    t3 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args1 =>
                                                                    if
                                                                    (args =?
                                                                    0) &&
                                                                    (args1 =?
                                                                    0)
                                                                    then
                                                                    UnderLets.Base
                                                                    (x1,
                                                                    ##
                                                                    (0)%expr)%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end
                                                                    | _ =>
                                                                    default
                                                                    end in
                                                                    match
                                                                    x1
                                                                    with
                                                                    | #
                                                                    (idc1)%expr_pat =>
                                                                    match
                                                                    match
                                                                    idc1
                                                                    with
                                                                    | @ident.Literal
                                                                    t2 v =>
                                                                    match
                                                                    t2 as t3
                                                                    return
                                                                    (base.base_interp
                                                                    t3 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                    with
                                                                    | Some
                                                                    args1 =>
                                                                    if
                                                                    (args =?
                                                                    0) &&
                                                                    (args1 =?
                                                                    0)
                                                                    then
                                                                    UnderLets.Base
                                                                    (x2,
                                                                    ##
                                                                    (0)%expr)%expr_pat
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default2
                                                                    tt
                                                                    end
                                                                    | _ =>
                                                                    default2
                                                                    tt
                                                                    end
                                                                   | None =>
                                                                    default1
                                                                    tt
                                                                   end
                                                               | _ =>
                                                                   default1
                                                                    tt
                                                               end in
                                                               match x2 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    if
                                                                    (args0 <=?
                                                                    0) &&
                                                                    (args <=?
                                                                    0) &&
                                                                    (args0 +
                                                                    args <? 0)
                                                                    then
                                                                    UnderLets.UnderLet
                                                                    (#
                                                                    (ident.Z_sub_with_get_borrow)%expr @
                                                                    x @
                                                                    ##
                                                                    ((- args)%Z)%expr @
                                                                    x1 @
                                                                    ##
                                                                    ((- args0)%Z)%expr)%expr_pat
                                                                    (fun
                                                                    v : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                    =>
                                                                    UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v)%expr,
                                                                    (-
                                                                    (#
                                                                    (ident.snd)%expr @
                                                                    $v)%expr_pat)%expr)%expr_pat)
                                                                    else
                                                                    default
                                                                   | None =>
                                                                    default1
                                                                    tt
                                                                   end
                                                               | _ =>
                                                                   default1
                                                                    tt
                                                               end in
                                              match x1 with
                                              | #(idc0)%expr_pat =>
                                                  match
                                                    match idc0 with
                                                    | @ident.Literal t1 v =>
                                                        match
                                                          t1 as t2
                                                          return
                                                            (base.base_interp
                                                               t2 -> 
                                                             option Z)
                                                        with
                                                        | base.type.unit =>
                                                            fun _ : unit =>
                                                            None
                                                        | base.type.Z =>
                                                            fun v0 : Z =>
                                                            Some v0
                                                        | base.type.bool =>
                                                            fun _ : bool =>
                                                            None
                                                        | base.type.nat =>
                                                            fun _ : nat =>
                                                            None
                                                        end v
                                                    | _ => None
                                                    end
                                                  with
                                                  | Some args0 =>
                                                      if
                                                       (args0 <=? 0) &&
                                                       (args <=? 0) &&
                                                       (args0 + args <? 0)
                                                      then
                                                       UnderLets.UnderLet
                                                         (#(ident.Z_sub_with_get_borrow)%expr @
                                                          x @
                                                          ##((- args)%Z)%expr @
                                                          x2 @
                                                          ##((- args0)%Z)%expr)%expr_pat
                                                         (fun
                                                            v : var
                                                                  (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                          =>
                                                          UnderLets.Base
                                                            (#(ident.fst)%expr @
                                                             ($v)%expr,
                                                            (-
                                                             (#(ident.snd)%expr @
                                                              $v)%expr_pat)%expr)%expr_pat)
                                                      else default
                                                  | None => default1 tt
                                                  end
                                              | _ => default1 tt
                                              end in
                             match x2 with
                             | @expr.App _ _ _ s _ #(idc0)%expr_pat x3 =>
                                 match
                                   match idc0 with
                                   | ident.Z_opp => Some tt
                                   | _ => None
                                   end
                                 with
                                 | Some _ =>
                                     match
                                       s as t2
                                       return
                                         (Compile.value' false t2 ->
                                          UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                     with
                                     | type.base t2 =>
                                         fun v : defaults.expr (type.base t2)
                                         =>
                                         base.try_make_transport_cps
                                           (fun t1 : base.type =>
                                            defaults.expr (type.base t1)) t2
                                           base.type.Z
                                           (UnderLets.UnderLets base.type
                                              ident var
                                              (defaults.expr
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype)))
                                           (fun
                                              a : option
                                                    (defaults.expr
                                                       (type.base t2) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                            =>
                                            match a with
                                            | Some x' =>
                                                if args =? 0
                                                then
                                                 UnderLets.UnderLet
                                                   (#(ident.Z_sub_get_borrow)%expr @
                                                    x @ x1 @ x' v)%expr_pat
                                                   (fun
                                                      v0 : var
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)
                                                    =>
                                                    UnderLets.Base
                                                      (#(ident.fst)%expr @
                                                       ($v0)%expr,
                                                      (-
                                                       (#(ident.snd)%expr @
                                                        $v0)%expr_pat)%expr)%expr_pat)
                                                else
                                                 match
                                                   s as t3
                                                   return
                                                     (Compile.value' false t3 ->
                                                      UnderLets.UnderLets
                                                        base.type ident var
                                                        (defaults.expr
                                                           (type.base
                                                              (base.type.Z *
                                                               base.type.Z)%etype)))
                                                 with
                                                 | type.base t3 =>
                                                     fun
                                                       v0 : defaults.expr
                                                              (type.base t3)
                                                     =>
                                                     base.try_make_transport_cps
                                                       (fun t1 : base.type =>
                                                        defaults.expr
                                                          (type.base t1)) t3
                                                       base.type.Z
                                                       (UnderLets.UnderLets
                                                          base.type ident var
                                                          (defaults.expr
                                                             (type.base
                                                                (base.type.Z *
                                                                 base.type.Z)%etype)))
                                                       (fun
                                                          a0 : option
                                                                 (defaults.expr
                                                                    (type.base
                                                                    t3) ->
                                                                  defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                        =>
                                                        match a0 with
                                                        | Some x'0 =>
                                                            if args <? 0
                                                            then
                                                             UnderLets.UnderLet
                                                               (#(ident.Z_sub_with_get_borrow)%expr @
                                                                x @
                                                                ##((- args)%Z)%expr @
                                                                x1 @ 
                                                                x'0 v0)%expr_pat
                                                               (fun
                                                                  v1 : 
                                                                   var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                =>
                                                                UnderLets.Base
                                                                  (#(ident.fst)%expr @
                                                                   ($v1)%expr,
                                                                  (-
                                                                   (#
                                                                    (ident.snd)%expr @
                                                                    $v1)%expr_pat)%expr)%expr_pat)
                                                            else default
                                                        | None => default
                                                        end)
                                                 | (s0 -> d0)%ptype =>
                                                     fun
                                                       _ : Compile.value'
                                                             false s0 ->
                                                           Compile.value'
                                                             true d0 =>
                                                     default
                                                 end (Compile.reflect x3)
                                            | None => default
                                            end)
                                     | (s0 -> d0)%ptype =>
                                         fun
                                           _ : Compile.value' false s0 ->
                                               Compile.value' true d0 =>
                                         default
                                     end (Compile.reflect x3)
                                 | None => default
                                 end
                             | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _
                               _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                               _ _ _ s _ (_ @ _)%expr_pat _ | @expr.App _ _ _
                               s _ (@expr.LetIn _ _ _ _ _ _ _) _ => default
                             | _ => default1 tt
                             end in
            match x1 with
            | @expr.App _ _ _ s _ #(idc0)%expr_pat x3 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               if args =? 0
                               then
                                UnderLets.UnderLet
                                  (#(ident.Z_sub_get_borrow)%expr @ x @ x2 @
                                   x' v)%expr_pat
                                  (fun
                                     v0 : var
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)
                                   =>
                                   UnderLets.Base
                                     (#(ident.fst)%expr @ ($v0)%expr,
                                     (- (#(ident.snd)%expr @ $v0)%expr_pat)%expr)%expr_pat)
                               else
                                match
                                  s as t3
                                  return
                                    (Compile.value' false t3 ->
                                     UnderLets.UnderLets base.type ident var
                                       (defaults.expr
                                          (type.base
                                             (base.type.Z * base.type.Z)%etype)))
                                with
                                | type.base t3 =>
                                    fun v0 : defaults.expr (type.base t3) =>
                                    base.try_make_transport_cps
                                      (fun t1 : base.type =>
                                       defaults.expr (type.base t1)) t3
                                      base.type.Z
                                      (UnderLets.UnderLets base.type ident
                                         var
                                         (defaults.expr
                                            (type.base
                                               (base.type.Z * base.type.Z)%etype)))
                                      (fun
                                         a0 : option
                                                (defaults.expr (type.base t3) ->
                                                 defaults.expr
                                                   (type.base base.type.Z))
                                       =>
                                       match a0 with
                                       | Some x'0 =>
                                           if args <? 0
                                           then
                                            UnderLets.UnderLet
                                              (#(ident.Z_sub_with_get_borrow)%expr @
                                               x @ ##((- args)%Z)%expr @ x2 @
                                               x'0 v0)%expr_pat
                                              (fun
                                                 v1 : var
                                                        (type.base
                                                           (base.type.Z *
                                                            base.type.Z)%etype)
                                               =>
                                               UnderLets.Base
                                                 (#(ident.fst)%expr @
                                                  ($v1)%expr,
                                                 (-
                                                  (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                           else default
                                       | None => default
                                       end)
                                | (s0 -> d0)%ptype =>
                                    fun
                                      _ : Compile.value' false s0 ->
                                          Compile.value' true d0 => default
                                end (Compile.reflect x3)
                           | None => default
                           end)
                    | (s0 -> d0)%ptype =>
                        fun
                          _ : Compile.value' false s0 ->
                              Compile.value' true d0 => default
                    end (Compile.reflect x3)
                | None => default
                end
            | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s _
              (@expr.LetIn _ _ _ _ _ _ _) _ => default
            | _ => default1 tt
            end
        | None => default0 tt
        end
    | @expr.App _ _ _ s _ #(idc)%expr_pat x3 =>
        match match idc with
              | ident.Z_opp => Some tt
              | _ => None
              end with
        | Some _ =>
            llet default1 := fun 'tt =>
                             llet default1 := fun 'tt =>
                                              llet default1 := fun 'tt =>
                                                               match x2 with
                                                               | #(idc0)%expr_pat =>
                                                                   match
                                                                    match
                                                                    idc0
                                                                    with
                                                                    | @ident.Literal
                                                                    t1 v =>
                                                                    match
                                                                    t1 as t2
                                                                    return
                                                                    (base.base_interp
                                                                    t2 ->
                                                                    option Z)
                                                                    with
                                                                    | base.type.unit =>
                                                                    fun
                                                                    _ : unit
                                                                    => None
                                                                    | base.type.Z =>
                                                                    fun
                                                                    v0 : Z =>
                                                                    Some v0
                                                                    | base.type.bool =>
                                                                    fun
                                                                    _ : bool
                                                                    => None
                                                                    | base.type.nat =>
                                                                    fun
                                                                    _ : nat
                                                                    => None
                                                                    end v
                                                                    | _ =>
                                                                    None
                                                                    end
                                                                   with
                                                                   | Some
                                                                    args0 =>
                                                                    match
                                                                    s as t2
                                                                    return
                                                                    (Compile.value'
                                                                    false t2 ->
                                                                    UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    with
                                                                    | type.base
                                                                    t2 =>
                                                                    fun
                                                                    v : 
                                                                    defaults.expr
                                                                    (type.base
                                                                    t2) =>
                                                                    base.try_make_transport_cps
                                                                    (fun
                                                                    t1 : base.type
                                                                    =>
                                                                    defaults.expr
                                                                    (type.base
                                                                    t1)) t2
                                                                    base.type.Z
                                                                    (UnderLets.UnderLets
                                                                    base.type
                                                                    ident var
                                                                    (defaults.expr
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                                    (fun
                                                                    a : 
                                                                    option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                                    =>
                                                                    match
                                                                    a
                                                                    with
                                                                    | Some
                                                                    x' =>
                                                                    if
                                                                    args0 <=?
                                                                    0
                                                                    then
                                                                    UnderLets.UnderLet
                                                                    (#
                                                                    (ident.Z_sub_with_get_borrow)%expr @
                                                                    x @ 
                                                                    x' v @ x1 @
                                                                    ##
                                                                    ((- args0)%Z)%expr)%expr_pat
                                                                    (fun
                                                                    v0 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                    =>
                                                                    UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v0)%expr,
                                                                    (-
                                                                    (#
                                                                    (ident.snd)%expr @
                                                                    $v0)%expr_pat)%expr)%expr_pat)
                                                                    else
                                                                    default
                                                                    | None =>
                                                                    default
                                                                    end)
                                                                    | (s0 ->
                                                                    d0)%ptype =>
                                                                    fun
                                                                    _ : 
                                                                    Compile.value'
                                                                    false s0 ->
                                                                    Compile.value'
                                                                    true d0
                                                                    =>
                                                                    default
                                                                    end
                                                                    (Compile.reflect
                                                                    x3)
                                                                   | None =>
                                                                    default
                                                                   end
                                                               | _ => default
                                                               end in
                                              match x1 with
                                              | #(idc0)%expr_pat =>
                                                  match
                                                    match idc0 with
                                                    | @ident.Literal t1 v =>
                                                        match
                                                          t1 as t2
                                                          return
                                                            (base.base_interp
                                                               t2 -> 
                                                             option Z)
                                                        with
                                                        | base.type.unit =>
                                                            fun _ : unit =>
                                                            None
                                                        | base.type.Z =>
                                                            fun v0 : Z =>
                                                            Some v0
                                                        | base.type.bool =>
                                                            fun _ : bool =>
                                                            None
                                                        | base.type.nat =>
                                                            fun _ : nat =>
                                                            None
                                                        end v
                                                    | _ => None
                                                    end
                                                  with
                                                  | Some args0 =>
                                                      match
                                                        s as t2
                                                        return
                                                          (Compile.value'
                                                             false t2 ->
                                                           UnderLets.UnderLets
                                                             base.type ident
                                                             var
                                                             (defaults.expr
                                                                (type.base
                                                                   (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                      with
                                                      | type.base t2 =>
                                                          fun
                                                            v : defaults.expr
                                                                  (type.base
                                                                    t2) =>
                                                          base.try_make_transport_cps
                                                            (fun
                                                               t1 : base.type
                                                             =>
                                                             defaults.expr
                                                               (type.base t1))
                                                            t2 base.type.Z
                                                            (UnderLets.UnderLets
                                                               base.type
                                                               ident var
                                                               (defaults.expr
                                                                  (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)))
                                                            (fun
                                                               a : option
                                                                    (defaults.expr
                                                                    (type.base
                                                                    t2) ->
                                                                    defaults.expr
                                                                    (type.base
                                                                    base.type.Z))
                                                             =>
                                                             match a with
                                                             | Some x' =>
                                                                 if
                                                                  args0 <=? 0
                                                                 then
                                                                  UnderLets.UnderLet
                                                                    (#
                                                                    (ident.Z_sub_with_get_borrow)%expr @
                                                                    x @ 
                                                                    x' v @ x2 @
                                                                    ##
                                                                    ((- args0)%Z)%expr)%expr_pat
                                                                    (fun
                                                                    v0 : 
                                                                    var
                                                                    (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                                    =>
                                                                    UnderLets.Base
                                                                    (
                                                                    #
                                                                    (ident.fst)%expr @
                                                                    ($v0)%expr,
                                                                    (-
                                                                    (#
                                                                    (ident.snd)%expr @
                                                                    $v0)%expr_pat)%expr)%expr_pat)
                                                                 else default
                                                             | None =>
                                                                 default
                                                             end)
                                                      | (s0 -> d0)%ptype =>
                                                          fun
                                                            _ : Compile.value'
                                                                  false s0 ->
                                                                Compile.value'
                                                                  true d0 =>
                                                          default
                                                      end
                                                        (Compile.reflect x3)
                                                  | None => default1 tt
                                                  end
                                              | _ => default1 tt
                                              end in
                             match x2 with
                             | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x4 =>
                                 match
                                   match idc0 with
                                   | ident.Z_opp => Some tt
                                   | _ => None
                                   end
                                 with
                                 | Some _ =>
                                     match
                                       s as t2
                                       return
                                         (Compile.value' false t2 ->
                                          UnderLets.UnderLets base.type ident
                                            var
                                            (defaults.expr
                                               (type.base
                                                  (base.type.Z * base.type.Z)%etype)))
                                     with
                                     | type.base t2 =>
                                         fun v : defaults.expr (type.base t2)
                                         =>
                                         base.try_make_transport_cps
                                           (fun t1 : base.type =>
                                            defaults.expr (type.base t1)) t2
                                           base.type.Z
                                           (UnderLets.UnderLets base.type
                                              ident var
                                              (defaults.expr
                                                 (type.base
                                                    (base.type.Z *
                                                     base.type.Z)%etype)))
                                           (fun
                                              a : option
                                                    (defaults.expr
                                                       (type.base t2) ->
                                                     defaults.expr
                                                       (type.base base.type.Z))
                                            =>
                                            match a with
                                            | Some x' =>
                                                match
                                                  s0 as t3
                                                  return
                                                    (Compile.value' false t3 ->
                                                     UnderLets.UnderLets
                                                       base.type ident var
                                                       (defaults.expr
                                                          (type.base
                                                             (base.type.Z *
                                                              base.type.Z)%etype)))
                                                with
                                                | type.base t3 =>
                                                    fun
                                                      v0 : defaults.expr
                                                             (type.base t3)
                                                    =>
                                                    base.try_make_transport_cps
                                                      (fun t1 : base.type =>
                                                       defaults.expr
                                                         (type.base t1)) t3
                                                      base.type.Z
                                                      (UnderLets.UnderLets
                                                         base.type ident var
                                                         (defaults.expr
                                                            (type.base
                                                               (base.type.Z *
                                                                base.type.Z)%etype)))
                                                      (fun
                                                         a0 : option
                                                                (defaults.expr
                                                                   (type.base
                                                                    t3) ->
                                                                 defaults.expr
                                                                   (type.base
                                                                    base.type.Z))
                                                       =>
                                                       match a0 with
                                                       | Some x'0 =>
                                                           UnderLets.UnderLet
                                                             (#(ident.Z_sub_with_get_borrow)%expr @
                                                              x @ x' v @ x1 @
                                                              x'0 v0)%expr_pat
                                                             (fun
                                                                v1 : 
                                                                 var
                                                                   (type.base
                                                                    (base.type.Z *
                                                                    base.type.Z)%etype)
                                                              =>
                                                              UnderLets.Base
                                                                (#(ident.fst)%expr @
                                                                 ($v1)%expr,
                                                                (-
                                                                 (#(ident.snd)%expr @
                                                                  $v1)%expr_pat)%expr)%expr_pat)
                                                       | None => default
                                                       end)
                                                | (s1 -> d1)%ptype =>
                                                    fun
                                                      _ : Compile.value'
                                                            false s1 ->
                                                          Compile.value' true
                                                            d1 => default
                                                end (Compile.reflect x4)
                                            | None => default
                                            end)
                                     | (s1 -> d1)%ptype =>
                                         fun
                                           _ : Compile.value' false s1 ->
                                               Compile.value' true d1 =>
                                         default
                                     end (Compile.reflect x3)
                                 | None => default
                                 end
                             | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _
                               _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App
                               _ _ _ s0 _ (_ @ _)%expr_pat _ | @expr.App _ _
                               _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _ =>
                                 default
                             | _ => default1 tt
                             end in
            match x1 with
            | @expr.App _ _ _ s0 _ #(idc0)%expr_pat x4 =>
                match
                  match idc0 with
                  | ident.Z_opp => Some tt
                  | _ => None
                  end
                with
                | Some _ =>
                    match
                      s as t2
                      return
                        (Compile.value' false t2 ->
                         UnderLets.UnderLets base.type ident var
                           (defaults.expr
                              (type.base (base.type.Z * base.type.Z)%etype)))
                    with
                    | type.base t2 =>
                        fun v : defaults.expr (type.base t2) =>
                        base.try_make_transport_cps
                          (fun t1 : base.type => defaults.expr (type.base t1))
                          t2 base.type.Z
                          (UnderLets.UnderLets base.type ident var
                             (defaults.expr
                                (type.base (base.type.Z * base.type.Z)%etype)))
                          (fun
                             a : option
                                   (defaults.expr (type.base t2) ->
                                    defaults.expr (type.base base.type.Z)) =>
                           match a with
                           | Some x' =>
                               match
                                 s0 as t3
                                 return
                                   (Compile.value' false t3 ->
                                    UnderLets.UnderLets base.type ident var
                                      (defaults.expr
                                         (type.base
                                            (base.type.Z * base.type.Z)%etype)))
                               with
                               | type.base t3 =>
                                   fun v0 : defaults.expr (type.base t3) =>
                                   base.try_make_transport_cps
                                     (fun t1 : base.type =>
                                      defaults.expr (type.base t1)) t3
                                     base.type.Z
                                     (UnderLets.UnderLets base.type ident var
                                        (defaults.expr
                                           (type.base
                                              (base.type.Z * base.type.Z)%etype)))
                                     (fun
                                        a0 : option
                                               (defaults.expr (type.base t3) ->
                                                defaults.expr
                                                  (type.base base.type.Z)) =>
                                      match a0 with
                                      | Some x'0 =>
                                          UnderLets.UnderLet
                                            (#(ident.Z_sub_with_get_borrow)%expr @
                                             x @ x' v @ x2 @ x'0 v0)%expr_pat
                                            (fun
                                               v1 : var
                                                      (type.base
                                                         (base.type.Z *
                                                          base.type.Z)%etype)
                                             =>
                                             UnderLets.Base
                                               (#(ident.fst)%expr @
                                                ($v1)%expr,
                                               (-
                                                (#(ident.snd)%expr @ $v1)%expr_pat)%expr)%expr_pat)
                                      | None => default
                                      end)
                               | (s1 -> d1)%ptype =>
                                   fun
                                     _ : Compile.value' false s1 ->
                                         Compile.value' true d1 => default
                               end (Compile.reflect x4)
                           | None => default
                           end)
                    | (s1 -> d1)%ptype =>
                        fun
                          _ : Compile.value' false s1 ->
                              Compile.value' true d1 => default
                    end (Compile.reflect x3)
                | None => default
                end
            | @expr.App _ _ _ s0 _ ($_)%expr _ | @expr.App _ _ _ s0 _
              (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s0 _
              (_ @ _)%expr_pat _ | @expr.App _ _ _ s0 _
              (@expr.LetIn _ _ _ _ _ _ _) _ => default
            | _ => default1 tt
            end
        | None => default
        end
    | @expr.App _ _ _ s _ ($_)%expr _ | @expr.App _ _ _ s _
      (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _ (_ @ _)%expr_pat _ |
      @expr.App _ _ _ s _ (@expr.LetIn _ _ _ _ _ _ _) _ => default
    | _ => default0 tt
    end
| ident.Z_sub_get_borrow =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet _ := UnderLets.Base
                (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat in
    UnderLets.UnderLet
      (#(ident.Z_sub_get_borrow)%expr @ x @ x0 @ x1)%expr_pat
      (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
       UnderLets.Base
         (#(ident.fst)%expr @ ($v)%expr, #(ident.snd)%expr @ ($v)%expr)%expr_pat)
| ident.Z_sub_with_get_borrow =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    llet _ := UnderLets.Base
                (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat in
    UnderLets.UnderLet
      (#(ident.Z_sub_with_get_borrow)%expr @ x @ x0 @ x1 @ x2)%expr_pat
      (fun v : var (type.base (base.type.Z * base.type.Z)%etype) =>
       UnderLets.Base
         (#(ident.fst)%expr @ ($v)%expr, #(ident.snd)%expr @ ($v)%expr)%expr_pat)
| ident.Z_zselect =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_zselect)%expr @ x @ x0 @ x1)%expr_pat in
    default
| ident.Z_add_modulo =>
    fun x x0 x1 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_add_modulo)%expr @ x @ x0 @ x1)%expr_pat in
    default
| ident.Z_rshi =>
    fun x x0 x1 x2 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base
                      (#(ident.Z_rshi)%expr @ x @ x0 @ x1 @ x2)%expr_pat in
    default
| ident.Z_cc_m =>
    fun x x0 : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_cc_m)%expr @ x @ x0)%expr_pat in
    default
| ident.Z_cast range =>
    fun x : defaults.expr (type.base base.type.Z) =>
    llet default := UnderLets.Base (#(ident.Z_cast range)%expr @ x)%expr_pat in
    default
| ident.Z_cast2 range =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base (#(ident.Z_cast2 range)%expr @ x)%expr_pat in
    match x with
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ #(idc)%expr_pat x1) x0 =>
        match
          match idc with
          | @ident.pair A B => Some (A, B)
          | _ => None
          end
        with
        | Some _ =>
            match
              s0 as t2
              return
                (Compile.value' false t2 ->
                 UnderLets.UnderLets base.type ident var
                   (defaults.expr
                      (type.base (base.type.Z * base.type.Z)%etype)))
            with
            | type.base t2 =>
                fun v : defaults.expr (type.base t2) =>
                base.try_make_transport_cps
                  (fun t0 : base.type => defaults.expr (type.base t0)) t2
                  base.type.Z
                  (UnderLets.UnderLets base.type ident var
                     (defaults.expr
                        (type.base (base.type.Z * base.type.Z)%etype)))
                  (fun
                     a : option
                           (defaults.expr (type.base t2) ->
                            defaults.expr (type.base base.type.Z)) =>
                   match a with
                   | Some x' =>
                       match
                         s as t3
                         return
                           (Compile.value' false t3 ->
                            UnderLets.UnderLets base.type ident var
                              (defaults.expr
                                 (type.base (base.type.Z * base.type.Z)%etype)))
                       with
                       | type.base t3 =>
                           fun v0 : defaults.expr (type.base t3) =>
                           base.try_make_transport_cps
                             (fun t0 : base.type =>
                              defaults.expr (type.base t0)) t3 base.type.Z
                             (UnderLets.UnderLets base.type ident var
                                (defaults.expr
                                   (type.base
                                      (base.type.Z * base.type.Z)%etype)))
                             (fun
                                a0 : option
                                       (defaults.expr (type.base t3) ->
                                        defaults.expr (type.base base.type.Z))
                              =>
                              match a0 with
                              | Some x'0 =>
                                  (fv <-- do_again
                                            (base.type.Z * base.type.Z)
                                            (#(ident.Z_cast (fst range))%expr @
                                             ($(x' v))%expr,
                                            #(ident.Z_cast (snd range))%expr @
                                            ($(x'0 v0))%expr)%expr_pat;
                                   UnderLets.Base (id (id fv)))%under_lets
                              | None => default
                              end)
                       | (s1 -> d1)%ptype =>
                           fun
                             _ : Compile.value' false s1 ->
                                 Compile.value' true d1 => default
                       end (Compile.reflect x0)
                   | None => default
                   end)
            | (s1 -> d1)%ptype =>
                fun _ : Compile.value' false s1 -> Compile.value' true d1 =>
                default
            end (Compile.reflect x1)
        | None => default
        end
    | @expr.App _ _ _ s _ (@expr.App _ _ _ s0 _ ($_)%expr _) _ | @expr.App _
      _ _ s _ (@expr.App _ _ _ s0 _ (@expr.Abs _ _ _ _ _ _) _) _ | @expr.App
      _ _ _ s _ (@expr.App _ _ _ s0 _ (_ @ _)%expr_pat _) _ | @expr.App _ _ _
      s _ (@expr.App _ _ _ s0 _ (@expr.LetIn _ _ _ _ _ _ _) _) _ => default
    | @expr.App _ _ _ s _ #(_)%expr_pat _ | @expr.App _ _ _ s _ ($_)%expr _ |
      @expr.App _ _ _ s _ (@expr.Abs _ _ _ _ _ _) _ | @expr.App _ _ _ s _
      (@expr.LetIn _ _ _ _ _ _ _) _ => default
    | _ => default
    end
| ident.fancy_add log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_add log2wordmax imm)%expr @ x)%expr_pat in
    default
| ident.fancy_addc log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_addc log2wordmax imm)%expr @ x)%expr_pat in
    default
| ident.fancy_sub log2wordmax imm =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_sub log2wordmax imm)%expr @ x)%expr_pat in
    default
| ident.fancy_subb log2wordmax imm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_subb log2wordmax imm)%expr @ x)%expr_pat in
    default
| ident.fancy_mulll log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_mulll log2wordmax)%expr @ x)%expr_pat in
    default
| ident.fancy_mullh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_mullh log2wordmax)%expr @ x)%expr_pat in
    default
| ident.fancy_mulhl log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_mulhl log2wordmax)%expr @ x)%expr_pat in
    default
| ident.fancy_mulhh log2wordmax =>
    fun x : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_mulhh log2wordmax)%expr @ x)%expr_pat in
    default
| ident.fancy_rshi log2wordmax x =>
    fun x0 : defaults.expr (type.base (base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_rshi log2wordmax x)%expr @ x0)%expr_pat in
    default
| ident.fancy_selc =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base (#(ident.fancy_selc)%expr @ x)%expr_pat in
    default
| ident.fancy_selm log2wordmax =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base
                      (#(ident.fancy_selm log2wordmax)%expr @ x)%expr_pat in
    default
| ident.fancy_sell =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base (#(ident.fancy_sell)%expr @ x)%expr_pat in
    default
| ident.fancy_addm =>
    fun
      x : defaults.expr
            (type.base (base.type.Z * base.type.Z * base.type.Z)%etype) =>
    llet default := UnderLets.Base (#(ident.fancy_addm)%expr @ x)%expr_pat in
    default
end
     : Compile.value' true t
